{"version":3,"sources":["PathfindingVisualizer/Node/Node.jsx","algorithms/dijkstra.js","algorithms/Astar.js","algorithms/DFS.js","algorithms/BFS.js","images/start_node.JPG","images/finish_node.JPG","images/shortest_path_node.JPG","images/visited_node.JPG","images/wall_node.JPG","PathfindingVisualizer/Navbar/Navbar.jsx","PathfindingVisualizer/PathfindingVisualizer.jsx","Popup/Popup.js","Popup/FinalPopupPage.js","Popup/Page1.js","images/pointAtoB.png","Popup/Page2.js","Popup/Page3.js","Popup/Page4.js","Popup/Page5.js","App.js","reportWebVitals.js","index.js"],"names":["Node","this","props","col","isFinish","isStart","isWall","onMouseDown","onMouseEnter","onMouseUp","row","extraClassName","id","className","Component","dijkstra","grid","startNode","finishNode","visitedNodesInOrder","distance","unvisitedNodes","nodes","node","push","getAllNodes","length","sortNodesByDistance","closestNode","shift","console","log","Infinity","isVisited","updateUnvisitedNeighbors","sort","nodeA","nodeB","unvisitedNeighbors","neighbors","filter","neighbor","getUnvisitedNeighbors","previousNode","updateExploredNodes","exploredNodes","nodeToRemove","calculateHcost","nodeRow","nodeCol","finishNodeRow","finishNodeCol","y_diff_squared","Math","pow","abs","x_diff_squared","sqrt","calculateGcost","currentNode","diagonal","G_cost","Gcost","exploreNodes","oldNode","previousGcost","Hcost","isExplored","Fcost","sortNodesByFcost","H_cost","checkTop","topNode","checkRight","rightNode","checkBottom","bottomNode","checkLeft","leftNode","checkBackTrack","i","checkPaths","inQueue","checkSurroundingNodes","nodeQueue","NavBar","state","algorithm","speed","setState","visualizeDijkstra","visualizeAstar","visualizeDFS","visualizeBFS","class","onClick","selectDijkstra","selectAstar","selectDFS","selectBFS","visualizeAlgorithm","setFast","setAverage","setSlow","clearWalls","src","start_node","alt","finish_node","wall_node","visited_node","shortest_path_node","PathfindingVisualizer","mouseIsPressed","finishNodePressed","startNodePressed","startNodeRow","startNodeCol","bind","getInitialGrid","newGrid","getNewGridWithWallToggled","getNewGridWithEndNode","getNewGridWithStartNode","nodesInShortestPathOrder","setTimeout","animateShortestPath","document","getElementById","rate","unshift","getNodesInShortestPathOrder","animateDijkstra","Astar","getNodesInShortestPathOrderAstar","DFS","getNodesInShortestPathOrderDFS","BFS","getNodesInShortestPathOrderBFS","type","plainGrid","getInitialGridForClear","j","createNode","map","rowIdx","nodeIdx","handleMouseDown","handleMouseEnter","handleMouseUp","currentRow","createNodeForClear","slice","newNode","Popup","trigger","children","setTrigger","setPage","page","FinalPopupPage","Page1","Page2","width","Page3","Page4","Page5","App","useState","timedPopup","setTimedPopup","useEffect","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode"],"mappings":"uXAIqBA,E,4JACnB,WACE,MASIC,KAAKC,MARPC,EADF,EACEA,IACAC,EAFF,EAEEA,SACAC,EAHF,EAGEA,QACAC,EAJF,EAIEA,OACAC,EALF,EAKEA,YACAC,EANF,EAMEA,aACAC,EAPF,EAOEA,UACAC,EARF,EAQEA,IAEIC,EAAiBP,EACnB,cACAC,EACA,aACAC,EACA,YACA,GAEJ,OACE,qBACEM,GAAE,eAAUF,EAAV,YAAiBP,GACnBU,UAAS,eAAUF,GACnBJ,YAAa,kBAAMA,EAAYG,EAAKP,IACpCK,aAAc,kBAAMA,EAAaE,EAAKP,IACtCM,UAAW,kBAAMA,W,GA1BSK,a,OCA3B,SAASC,EAASC,EAAMC,EAAWC,GACxC,IAAMC,EAAsB,GAE5BF,EAAUG,SAAW,EAGrB,IAFA,IAAMC,EA0CR,SAAqBL,GACnB,IADyB,EACnBM,EAAQ,GADW,cAEPN,GAFO,IAEzB,2BAAwB,CAAC,IAAD,EAAbN,EAAa,sBACHA,GADG,IACtB,2BAAwB,CAAC,IAAda,EAAa,QACtBD,EAAME,KAAKD,IAFS,gCAFC,8BAOzB,OAAOD,EAjDgBG,CAAYT,GAE5BK,EAAeK,QAAQ,CAC5BC,EAAoBN,GACpB,IAAMO,EAAcP,EAAeQ,QAGnC,GAFAC,QAAQC,IAAIH,EAAYR,WAEpBQ,EAAYtB,OAAhB,CAGA,GAAIsB,EAAYR,WAAaY,IAAU,OAAOb,EAG9C,GAFAS,EAAYK,WAAY,EACxBd,EAAoBK,KAAKI,GACrBA,IAAgBV,EAAY,OAAOC,EACvCe,EAAyBN,EAAaZ,KAI1C,SAASW,EAAoBN,GAC3BA,EAAec,MAAK,SAACC,EAAOC,GAAR,OAAkBD,EAAMhB,SAAWiB,EAAMjB,YAI/D,SAASc,EAAyBX,EAAMP,GACtC,IAD4C,EACtCsB,EAOR,SAA+Bf,EAAMP,GACnC,IAAMuB,EAAY,GACVpC,EAAaoB,EAAbpB,IAAKO,EAAQa,EAARb,IACTA,EAAM,GAAG6B,EAAUf,KAAKR,EAAKN,EAAM,GAAGP,IACtCO,EAAMM,EAAKU,OAAS,GAAGa,EAAUf,KAAKR,EAAKN,EAAM,GAAGP,IACpDA,EAAM,GAAGoC,EAAUf,KAAKR,EAAKN,GAAKP,EAAM,IACxCA,EAAMa,EAAK,GAAGU,OAAS,GAAGa,EAAUf,KAAKR,EAAKN,GAAKP,EAAM,IAE7D,OAAOoC,EAAUC,QAAO,SAACC,GAAD,OAAeA,EAASR,aAfrBS,CAAsBnB,EAAMP,GADX,cAErBsB,GAFqB,IAE5C,2BAA2C,CAAC,IAAjCG,EAAgC,QACzCA,EAASrB,SAAWG,EAAKH,SAAW,EACpCqB,EAASE,aAAepB,GAJkB,+BCG9C,SAASqB,EAAoBC,EAAeC,GAC1C,OAAIA,EAAaxC,OACRuC,EAGFA,EAAcL,QAAO,SAACjB,GAAD,OAAWuB,KAGzC,SAASC,EAAeC,EAASC,EAASC,EAAeC,GACvD,IAAMC,EAAiBC,KAAKC,IAAID,KAAKE,IAAIP,EAAUE,GAAgB,GAC7DM,EAAiBH,KAAKC,IAAID,KAAKE,IAAIN,EAAUE,GAAgB,GAEnE,OAD4D,GAA7CE,KAAKI,KAAKL,EAAiBI,GAI5C,SAASE,EAAeC,EAAaC,GACnC,IAAIC,EAASF,EAAYG,MAQzB,OALED,GADED,EACuB,GAAfP,KAAKI,KAAK,GAEV,GAMd,SAASM,EAAaJ,EAAa1C,EAAWC,EAAY2B,EAAe7B,GAEvE,IAAQN,EAAaiD,EAAbjD,IAAKP,EAAQwD,EAARxD,IAGb,GAAIO,EAAM,EAAG,CACX,IACMsD,EAAUhD,EAAKN,EAAM,GAAGP,GACxBoB,EAAOP,EAAKN,EAAM,GAAGP,GAErB8D,EAAgB1C,EAAKuC,MAC3BvC,EAAKuC,MAAQJ,EAAeC,GALX,GAOjBpC,EAAK2C,MAAQnB,EAAerC,EAAM,EAAGP,EAAKe,EAAWR,IAAKQ,EAAWf,KACjEoB,EAAKuC,MAAQG,GACfpB,EAAgBD,EAAoBC,EAAemB,GACnDzC,EAAK4C,YAAa,GAEG,MAAjBF,IACF1C,EAAKuC,MAAQG,GAGjB,IAAMG,EAAQ7C,EAAK2C,MAAQ3C,EAAKuC,MAChCvC,EAAK6C,MAAQA,EACR7C,EAAK4C,YAAe5C,EAAKjB,SAC5BiB,EAAK4C,YAAa,EAClBtB,EAAcrB,KAAKD,GACnBA,EAAKoB,aAAegB,GAKxB,GAAIjD,EAAMM,EAAKU,OAAS,EAAG,CACzB,IACMsC,EAAUhD,EAAKN,EAAM,GAAGP,GACxBoB,EAAOP,EAAKN,EAAM,GAAGP,GACrB8D,EAAgB1C,EAAKuC,MAC3BvC,EAAKuC,MAAQJ,EAAeC,GAJX,GAKjBpC,EAAK2C,MAAQnB,EAAerC,EAAM,EAAGP,EAAKe,EAAWR,IAAKQ,EAAWf,KACjEoB,EAAKuC,MAAQG,GACfpB,EAAgBD,EAAoBC,EAAemB,GACnDzC,EAAK4C,YAAa,GAEG,MAAjBF,IACF1C,EAAKuC,MAAQG,GAGjB,IAAMG,EAAQ7C,EAAK2C,MAAQ3C,EAAKuC,MAChCvC,EAAK6C,MAAQA,EACR7C,EAAK4C,YAAe5C,EAAKjB,SAC5BiB,EAAK4C,YAAa,EAClBtB,EAAcrB,KAAKD,GACnBA,EAAKoB,aAAegB,GAKxB,GAAIxD,EAAM,EAAG,CACX,IACM6D,EAAUhD,EAAKN,GAAKP,EAAM,GAC1BoB,EAAOP,EAAKN,GAAKP,EAAM,GACvB8D,EAAgB1C,EAAKuC,MAC3BvC,EAAKuC,MAAQJ,EAAeC,GAJX,GAKjBpC,EAAK2C,MAAQnB,EAAerC,EAAKP,EAAM,EAAGe,EAAWR,IAAKQ,EAAWf,KACjEoB,EAAKuC,MAAQG,GACfpB,EAAgBD,EAAoBC,EAAemB,GACnDzC,EAAK4C,YAAa,GAEG,MAAjBF,IACF1C,EAAKuC,MAAQG,GAGjB,IAAMG,EAAQ7C,EAAK2C,MAAQ3C,EAAKuC,MAChCvC,EAAK6C,MAAQA,EACR7C,EAAK4C,YAAe5C,EAAKjB,SAC5BiB,EAAK4C,YAAa,EAClBtB,EAAcrB,KAAKD,GACnBA,EAAKoB,aAAegB,GAKxB,GAAIxD,EAAMa,EAAK,GAAGU,OAAS,EAAG,CAC5B,IACMsC,EAAUhD,EAAKN,GAAKP,EAAM,GAC1BoB,EAAOP,EAAKN,GAAKP,EAAM,GACvB8D,EAAgB1C,EAAKuC,MAC3BvC,EAAKuC,MAAQJ,EAAeC,GAJX,GAKjBpC,EAAK2C,MAAQnB,EAAerC,EAAKP,EAAM,EAAGe,EAAWR,IAAKQ,EAAWf,KACjEoB,EAAKuC,MAAQG,GACfpB,EAAgBD,EAAoBC,EAAemB,GACnDzC,EAAK4C,YAAa,GAEG,MAAjBF,IACF1C,EAAKuC,MAAQG,GAGjB,IAAMG,EAAQ7C,EAAK2C,MAAQ3C,EAAKuC,MAChCvC,EAAK6C,MAAQA,EACR7C,EAAK4C,YAAe5C,EAAKjB,SAC5BiB,EAAK4C,YAAa,EAClBtB,EAAcrB,KAAKD,GACnBA,EAAKoB,aAAegB,GAKxB,GAAIjD,EAAM,GAAKP,EAAM,EAAG,CACtB,IACM6D,EAAUhD,EAAKN,EAAM,GAAGP,EAAM,GAC9BoB,EAAOP,EAAKN,EAAM,GAAGP,EAAM,GAC3B8D,EAAgB1C,EAAKuC,MAC3BvC,EAAKuC,MAAQJ,EAAeC,GAJX,GAKjBpC,EAAK2C,MAAQnB,EACXrC,EAAM,EACNP,EAAM,EACNe,EAAWR,IACXQ,EAAWf,KAEToB,EAAKuC,MAAQG,GACfpB,EAAgBD,EAAoBC,EAAemB,GACnDzC,EAAK4C,YAAa,GAEG,MAAjBF,IACF1C,EAAKuC,MAAQG,GAGjB,IAAMG,EAAQ7C,EAAK2C,MAAQ3C,EAAKuC,MAChCvC,EAAK6C,MAAQA,EACR7C,EAAK4C,YAAe5C,EAAKjB,SAC5BiB,EAAK4C,YAAa,EAClBtB,EAAcrB,KAAKD,GACnBA,EAAKoB,aAAegB,GAKxB,GAAIjD,EAAM,GAAKP,EAAMa,EAAK,GAAGU,OAAS,EAAG,CACvC,IACMsC,EAAUhD,EAAKN,EAAM,GAAGP,EAAM,GAC9BoB,EAAOP,EAAKN,EAAM,GAAGP,EAAM,GAC3B8D,EAAgB1C,EAAKuC,MAC3BvC,EAAKuC,MAAQJ,EAAeC,GAJX,GAKjBpC,EAAK2C,MAAQnB,EACXrC,EAAM,EACNP,EAAM,EACNe,EAAWR,IACXQ,EAAWf,KAEToB,EAAKuC,MAAQG,GACfpB,EAAgBD,EAAoBC,EAAemB,GACnDzC,EAAK4C,YAAa,GAEG,MAAjBF,IACF1C,EAAKuC,MAAQG,GAGjB,IAAMG,EAAQ7C,EAAK2C,MAAQ3C,EAAKuC,MAChCvC,EAAK6C,MAAQA,EACR7C,EAAK4C,YAAe5C,EAAKjB,SAC5BiB,EAAK4C,YAAa,EAClBtB,EAAcrB,KAAKD,GACnBA,EAAKoB,aAAegB,GAKxB,GAAIjD,EAAMM,EAAKU,OAAS,GAAKvB,EAAM,EAAG,CACpC,IACM6D,EAAUhD,EAAKN,EAAM,GAAGP,EAAM,GAC9BoB,EAAOP,EAAKN,EAAM,GAAGP,EAAM,GAC3B8D,EAAgB1C,EAAKuC,MAC3BvC,EAAKuC,MAAQJ,EAAeC,GAJX,GAKjBpC,EAAK2C,MAAQnB,EACXrC,EAAM,EACNP,EAAM,EACNe,EAAWR,IACXQ,EAAWf,KAEToB,EAAKuC,MAAQG,GACfpB,EAAgBD,EAAoBC,EAAemB,GACnDzC,EAAK4C,YAAa,GAEG,MAAjBF,IACF1C,EAAKuC,MAAQG,GAGjB,IAAMG,EAAQ7C,EAAK2C,MAAQ3C,EAAKuC,MAChCvC,EAAK6C,MAAQA,EACR7C,EAAK4C,YAAe5C,EAAKjB,SAC5BiB,EAAK4C,YAAa,EAClBtB,EAAcrB,KAAKD,GACnBA,EAAKoB,aAAegB,GAKxB,GAAIjD,EAAMM,EAAKU,OAAS,GAAKvB,EAAMa,EAAK,GAAGU,OAAS,EAAG,CACrD,IACMsC,EAAUhD,EAAKN,EAAM,GAAGP,EAAM,GAC9BoB,EAAOP,EAAKN,EAAM,GAAGP,EAAM,GAC3B8D,EAAgB1C,EAAKuC,MAC3BvC,EAAKuC,MAAQJ,EAAeC,GAJX,GAKjBpC,EAAK2C,MAAQnB,EACXrC,EAAM,EACNP,EAAM,EACNe,EAAWR,IACXQ,EAAWf,KAEToB,EAAKuC,MAAQG,GACfpB,EAAgBD,EAAoBC,EAAemB,GACnDzC,EAAK4C,YAAa,GAEG,MAAjBF,IACF1C,EAAKuC,MAAQG,GAGjB,IAAMG,EAAQ7C,EAAK2C,MAAQ3C,EAAKuC,MAChCvC,EAAK6C,MAAQA,EACR7C,EAAK4C,YAAe5C,EAAKjB,SAC5BiB,EAAK4C,YAAa,EAClBtB,EAAcrB,KAAKD,GACnBA,EAAKoB,aAAegB,IAK1B,SAASU,EAAiBxB,GACxBA,EAAcV,MAAK,SAACC,EAAOC,GAAR,OACjBD,EAAMgC,QAAU/B,EAAM+B,MAClBhC,EAAMkC,OAASjC,EAAM6B,MACrB9B,EAAMgC,MAAQ/B,EAAM+B,SCjQ5B,SAASG,EAASvD,EAAM2C,GACtB,IAAQjD,EAAaiD,EAAbjD,IAAKP,EAAQwD,EAARxD,IACb,GAAIO,EAAM,EAAG,CACX,IAAM8D,EAAUxD,EAAKN,EAAM,GAAGP,GAC9B,IAAKqE,EAAQvC,YAAcuC,EAAQlE,OAEjC,OADAkE,EAAQ7B,aAAegB,GAChB,EAIX,OAAO,EAGT,SAASc,EAAWzD,EAAM2C,GACxB,IAAQjD,EAAaiD,EAAbjD,IAAKP,EAAQwD,EAARxD,IACb,GAAIA,EAAMa,EAAK,GAAGU,OAAS,EAAG,CAC5B,IAAMgD,EAAY1D,EAAKN,GAAKP,EAAM,GAClC,IAAKuE,EAAUzC,YAAcyC,EAAUpE,OAErC,OADAoE,EAAU/B,aAAegB,GAClB,EAIX,OAAO,EAGT,SAASgB,EAAY3D,EAAM2C,GACzB,IAAQjD,EAAaiD,EAAbjD,IAAKP,EAAQwD,EAARxD,IACb,GAAIO,EAAMM,EAAKU,OAAS,EAAG,CACzB,IAAMkD,EAAa5D,EAAKN,EAAM,GAAGP,GACjC,IAAKyE,EAAW3C,YAAc2C,EAAWtE,OAEvC,OADAsE,EAAWjC,aAAegB,GACnB,EAIX,OAAO,EAGT,SAASkB,EAAU7D,EAAM2C,GACvB,IAAQjD,EAAaiD,EAAbjD,IAAKP,EAAQwD,EAARxD,IACb,GAAIA,EAAM,EAAG,CACX,IAAM2E,EAAW9D,EAAKN,GAAKP,EAAM,GACjC,IAAK2E,EAAS7C,YAAc6C,EAASxE,OAEnC,OADAwE,EAASnC,aAAegB,GACjB,EAIX,OAAO,EAGT,SAASoB,EAAe/D,EAAMG,GAG5B,IAFA,IAAIwC,EAAcxC,EAAoBA,EAAoBO,OAAS,GAC/DsD,EAAI,EAENA,EAAI7D,EAAoBO,SACvB6C,EAASvD,EAAM2C,KACfc,EAAWzD,EAAM2C,KACjBgB,EAAY3D,EAAM2C,KAClBkB,EAAU7D,EAAM2C,MAEfqB,EACFrB,EAAcxC,EAAoBA,EAAoBO,OAAS,EAAIsD,GAGrE,OAAIA,IAAM7D,EAAoBO,OACrB,EAAC,EAAO,MAER,EAAC,EAAMiC,GCnElB,SAASsB,EAAWjE,EAAM2C,GACxB,IAAQjD,EAAaiD,EAAbjD,IAAKP,EAAQwD,EAARxD,IAEb,GAAIO,EAAM,EAAG,CACX,IAAM8D,EAAUxD,EAAKN,EAAM,GAAGP,GAC9B,IAAKqE,EAAQvC,YAAcuC,EAAQlE,SAAWkE,EAAQU,QACpD,OAAO,EAIX,GAAI/E,EAAMa,EAAK,GAAGU,OAAS,EAAG,CAC5B,IAAMgD,EAAY1D,EAAKN,GAAKP,EAAM,GAClC,IAAKuE,EAAUzC,YAAcyC,EAAUpE,SAAWoE,EAAUQ,QAC1D,OAAO,EAIX,GAAIxE,EAAMM,EAAKU,OAAS,EAAG,CACzB,IAAMkD,EAAa5D,EAAKN,EAAM,GAAGP,GACjC,IAAKyE,EAAW3C,YAAc2C,EAAWtE,SAAWsE,EAAWM,QAC7D,OAAO,EAIX,GAAI/E,EAAM,EAAG,CACX,IAAM2E,EAAW9D,EAAKN,GAAKP,EAAM,GACjC,IAAK2E,EAAS7C,YAAc6C,EAASxE,SAAWwE,EAASI,QACvD,OAAO,EAIX,OAAO,EAGT,SAASC,EAAsBnE,EAAMoE,EAAWzB,GAC9C,IAAQjD,EAAaiD,EAAbjD,IAAKP,EAAQwD,EAARxD,IAEb,GAAIO,EAAM,EAAG,CACX,IAAM8D,EAAUxD,EAAKN,EAAM,GAAGP,GACzBqE,EAAQvC,WAAcuC,EAAQlE,QAAWkE,EAAQU,UACpDV,EAAQ7B,aAAegB,EACvBa,EAAQU,SAAU,EAClBE,EAAU5D,KAAKgD,IAInB,GAAIrE,EAAMa,EAAK,GAAGU,OAAS,EAAG,CAC5B,IAAMgD,EAAY1D,EAAKN,GAAKP,EAAM,GAC7BuE,EAAUzC,WAAcyC,EAAUpE,QAAWoE,EAAUQ,UAC1DR,EAAU/B,aAAegB,EACzBe,EAAUQ,SAAU,EACpBE,EAAU5D,KAAKkD,IAInB,GAAIhE,EAAMM,EAAKU,OAAS,EAAG,CACzB,IAAMkD,EAAa5D,EAAKN,EAAM,GAAGP,GAC5ByE,EAAW3C,WAAc2C,EAAWtE,QAAWsE,EAAWM,UAC7DN,EAAWjC,aAAegB,EAC1BiB,EAAWM,SAAU,EACrBE,EAAU5D,KAAKoD,IAInB,GAAIzE,EAAM,EAAG,CACX,IAAM2E,EAAW9D,EAAKN,GAAKP,EAAM,GAC5B2E,EAAS7C,WAAc6C,EAASxE,QAAWwE,EAASI,UACvDJ,EAASnC,aAAegB,EACxBmB,EAASI,SAAU,EACnBE,EAAU5D,KAAKsD,IAInB,OAAO,E,UC9GM,MAA0B,uCCA1B,MAA0B,wCCA1B,MAA0B,+CCA1B,MAA0B,yCCA1B,MAA0B,sCCSpBO,E,kDACnB,WAAYnF,GAAQ,IAAD,8BACjB,cAAMA,IACDoF,MAAQ,CACXC,UAAW,YACXC,MAAO,QAJQ,E,kDAQnB,WACEvF,KAAKwF,SAAS,CAACF,UAAW,yB,yBAG5B,WACEtF,KAAKwF,SAAS,CAACF,UAAW,mB,uBAG5B,WACEtF,KAAKwF,SAAS,CAACF,UAAW,oB,uBAG5B,WACEtF,KAAKwF,SAAS,CAACF,UAAW,oB,qBAG5B,WACEtF,KAAKwF,SAAS,CAACD,MAAO,W,wBAGxB,WACEvF,KAAKwF,SAAS,CAACD,MAAO,c,qBAGxB,WACEvF,KAAKwF,SAAS,CAACD,MAAO,W,gCAIxB,WAC8B,uBAAzBvF,KAAKqF,MAAMC,UACZtF,KAAKC,MAAMwF,kBAAkBzF,KAAKqF,MAAME,OAET,iBAAzBvF,KAAKqF,MAAMC,UACjBtF,KAAKC,MAAMyF,eAAe1F,KAAKqF,MAAME,OAEN,kBAAzBvF,KAAKqF,MAAMC,UACjBtF,KAAKC,MAAM0F,aAAa3F,KAAKqF,MAAME,OAEJ,kBAAzBvF,KAAKqF,MAAMC,UACjBtF,KAAKC,MAAM2F,aAAa5F,KAAKqF,MAAME,OAGnCvF,KAAKwF,SAAS,CAACF,UAAW,iC,oBAI9B,WAAW,IAAD,OACR,OACE,mCACA,qBAAK1E,UAAU,YAAf,SACE,sBAAKA,UAAU,iBAAf,UACE,sBAAKiF,MAAM,WAAX,UACE,wBAAQA,MAAM,UAAd,wBACA,sBAAKlF,GAAG,aAAakF,MAAM,mBAA3B,UACE,mBAAGC,QAAS,kBAAM,EAAKC,kBAAvB,iCACA,mBAAGD,QAAS,kBAAM,EAAKE,eAAvB,0BACA,mBAAGF,QAAS,kBAAM,EAAKG,aAAvB,2BACA,mBAAGH,QAAS,kBAAM,EAAKI,aAAvB,iCAGJ,wBAAQtF,UAAU,gBAAgBkF,QAAS,kBAAM,EAAKK,sBAAtD,SAA6EnG,KAAKqF,MAAMC,YACxF,sBAAKO,MAAM,WAAX,UACE,yBAAQA,MAAM,UAAd,oBAAgC7F,KAAKqF,MAAME,SAC3C,sBAAK5E,GAAG,aAAakF,MAAM,mBAA3B,UACE,mBAAGC,QAAS,kBAAM,EAAKM,WAAvB,kBACA,mBAAGN,QAAS,kBAAM,EAAKO,cAAvB,qBACA,mBAAGP,QAAS,kBAAM,EAAKQ,WAAvB,wBAGJ,sBAAKT,MAAM,WAAX,UACE,wBAAQA,MAAM,UAAd,mBACA,sBAAKlF,GAAG,aAAakF,MAAM,mBAA3B,UACE,mBAAGC,QAAS,kBAAM,EAAK7F,MAAMsG,WAAW,EAAKtG,MAAMoF,MAAMtE,KAAM,UAA/D,yBACA,mBAAG+E,QAAS,kBAAM,EAAK7F,MAAMsG,WAAW,EAAKtG,MAAMoF,MAAMtE,KAAM,SAA/D,wBACA,mBAAG+E,QAAS,kBAAM,EAAK7F,MAAMsG,WAAW,EAAKtG,MAAMoF,MAAMtE,KAAM,UAA/D,+BAGJ,sBAAKH,UAAU,MAAf,UACE,sBAAKA,UAAU,SAAf,UACE,4CACA,qBAAK4F,IAAKC,EAAYC,IAAI,kBAE5B,sBAAK9F,UAAU,SAAf,UACE,6CACA,qBAAK4F,IAAKG,EAAaD,IAAI,mBAE7B,sBAAK9F,UAAU,SAAf,UACE,2CACA,qBAAK4F,IAAKI,EAAWF,IAAI,iBAE3B,sBAAK9F,UAAU,SAAf,UACE,6CACA,qBAAK4F,IAAKK,EAAcH,IAAI,oBAE9B,sBAAK9F,UAAU,SAAf,UACE,oDACA,qBAAK4F,IAAKM,EAAoBJ,IAAI,wC,GA1GZ7F,aCMfkG,G,wDACnB,aAAe,IAAD,8BACZ,gBACK1B,MAAQ,CACXtE,KAAM,GACNiG,gBAAgB,EAChBC,mBAAmB,EACnBhE,cAVkB,GAWlBC,cAVkB,GAWlBgE,kBAAkB,EAClBC,aAfiB,GAgBjBC,aAfiB,IAkBnB,EAAKb,WAAa,EAAKA,WAAWc,KAAhB,gBAbN,E,qDAgBd,WACE,IAAMtG,EAAOuG,IACbtH,KAAKwF,SAAS,CAACzE,W,6BAGjB,SAAgBN,EAAKP,GACnB,GAAGO,IAAQT,KAAKqF,MAAMpC,eAAiB/C,IAAQF,KAAKqF,MAAMnC,cAIrD,GAAGzC,IAAQT,KAAKqF,MAAM8B,cAAgBjH,IAAQF,KAAKqF,MAAM+B,aAAzD,CAIL,IAAMG,EAAUC,EAA0BxH,KAAKqF,MAAMtE,KAAMN,EAAKP,GAChEF,KAAKwF,SAAS,CAACzE,KAAMwG,EAASP,gBAAgB,SAJ5ChH,KAAKwF,SAAS,CAACwB,gBAAgB,EAAME,kBAAkB,SAJvDlH,KAAKwF,SAAS,CAACwB,gBAAgB,EAAMC,mBAAmB,M,8BAW5D,SAAiBxG,EAAKP,GACpB,GAAKF,KAAKqF,MAAM2B,eAGX,GAAGhH,KAAKqF,MAAM4B,kBAAkB,CACnC,IAAMM,EAAUE,EAAsBzH,KAAKqF,MAAMtE,KAAMN,EAAKP,GAC5DF,KAAKwF,SAAS,CAACtC,cAAehD,EAAK+C,cAAexC,IAClDT,KAAKwF,SAAS,CAACzE,KAAMwG,SAElB,GAAGvH,KAAKqF,MAAM6B,iBAAiB,CAClC,IAAMK,EAAUG,EAAwB1H,KAAKqF,MAAMtE,KAAMN,EAAKP,GAC9DF,KAAKwF,SAAS,CAAC4B,aAAclH,EAAKiH,aAAc1G,IAChDT,KAAKwF,SAAS,CAACzE,KAAMwG,QAElB,CACH,IAAMA,EAAUC,EAA0BxH,KAAKqF,MAAMtE,KAAMN,EAAKP,GAChEF,KAAKwF,SAAS,CAACzE,KAAMwG,O,2BAKzB,WACEvH,KAAKwF,SAAS,CAACwB,gBAAgB,EAAOC,mBAAmB,EAAOC,kBAAkB,M,6BAGpF,SAAgBhG,EAAqByG,EAA0BpC,GAC7D,IADqE,IAAD,kBAC3DR,GACP,GAAIA,IAAM7D,EAAoBO,OAI5B,OAHAmG,YAAW,WACT,EAAKC,oBAAoBF,KACxBpC,EAAQR,GACL,CAAN,UAEF6C,YAAW,WACT/F,QAAQC,IAAIyD,GACZ,IAAMjE,EAAOJ,EAAoB6D,GACjC+C,SAASC,eAAT,eAAgCzG,EAAKb,IAArC,YAA4Ca,EAAKpB,MAAOU,UACtD,sBACD2E,EAAQR,IAZJA,EAAI,EAAGA,GAAK7D,EAAoBO,OAAQsD,IAAK,CAAC,IAAD,IAA7CA,GAA6C,qC,iCAgBxD,SAAoB4C,GAClB,IAD6C,IAAD,WACnC5C,GACP6C,YAAW,WACT,IAAMtG,EAAOqG,EAAyB5C,GACtC+C,SAASC,eAAT,eAAgCzG,EAAKb,IAArC,YAA4Ca,EAAKpB,MAAOU,UACtD,4BACD,GAAKmE,IALDA,EAAI,EAAGA,EAAI4C,EAAyBlG,OAAQsD,IAAM,EAAlDA,K,+BAUX,SAAkBQ,GAChB,IAAIyC,EAAO,GACE,SAAVzC,EACDyC,EAAO,GAES,YAAVzC,EACNyC,EAAO,GAES,SAAVzC,IACNyC,EAAO,KAET,IAAOjH,EAAQf,KAAKqF,MAAbtE,KACDC,EAAYD,EAAKf,KAAKqF,MAAM8B,cAAcnH,KAAKqF,MAAM+B,cACrDnG,EAAaF,EAAKf,KAAKqF,MAAMpC,eAAejD,KAAKqF,MAAMnC,eACvDhC,EAAsBJ,EAASC,EAAMC,EAAWC,GAChD0G,EVxDH,SAAqC1G,GAG1C,IAFA,IAAM0G,EAA2B,GAC7BjE,EAAczC,EACK,OAAhByC,GACLiE,EAAyBM,QAAQvE,GACjCA,EAAcA,EAAYhB,aAE5B,OAAOiF,EUiD4BO,CAA4BjH,GAC7DjB,KAAKmI,gBAAgBjH,EAAqByG,EAA0BK,K,4BAGtE,SAAezC,GACb,IAAIyC,EAAO,GACE,SAAVzC,EACDyC,EAAO,GAES,YAAVzC,EACNyC,EAAO,GAES,SAAVzC,IACNyC,EAAO,KAET,IAAOjH,EAAQf,KAAKqF,MAAbtE,KACDC,EAAYD,EAAKf,KAAKqF,MAAM8B,cAAcnH,KAAKqF,MAAM+B,cACrDnG,EAAaF,EAAKf,KAAKqF,MAAMpC,eAAejD,KAAKqF,MAAMnC,eACvDhC,ETpIH,SAAeH,EAAMC,EAAWC,GACrC,IAAM2B,EAAgB,GAChB1B,EAAsB,GAK5B,IAJAF,EAAUmD,MAAQ,EAClBnD,EAAU6C,MAAQ,EAClBjB,EAAcrB,KAAKP,KAEH,CAEdoD,EAAiBxB,GAGjB,IAAMc,EAAcd,EAAchB,QAGlC,GAFAC,QAAQC,IAAI4B,GAEe,qBAAhBA,IAA+BA,EAAYrD,OAAtD,CAMA,GAFAqD,EAAY1B,WAAY,EACxBd,EAAoBK,KAAKmC,GACrBA,IAAgBzC,EAClB,OAAOC,EAIT4C,EAAaJ,EAAa1C,EAAWC,EAAY2B,EAAe7B,KS0GpCqH,CAAMrH,EAAMC,EAAWC,GAC7C0G,ETiKH,SAA0C1G,GAG/C,IAFA,IAAM0G,EAA2B,GAC7BjE,EAAczC,IACH,CACb,GAAIyC,EAAYtD,QAAS,CACvBuH,EAAyBM,QAAQvE,GACjC,MAEFiE,EAAyBM,QAAQvE,GACjCA,EAAcA,EAAYhB,aAE5B,OAAOiF,ES5K4BU,CAAiCpH,GAClEjB,KAAKmI,gBAAgBjH,EAAqByG,EAA0BK,K,0BAGtE,SAAazC,GACX,IAAIyC,EAAO,GACE,SAAVzC,EACDyC,EAAO,GAES,YAAVzC,EACNyC,EAAO,GAES,SAAVzC,IACNyC,EAAO,KAET,IAAOjH,EAAQf,KAAKqF,MAAbtE,KACDC,EAAYD,EAAKf,KAAKqF,MAAM8B,cAAcnH,KAAKqF,MAAM+B,cACrDnG,EAAaF,EAAKf,KAAKqF,MAAMpC,eAAejD,KAAKqF,MAAMnC,eACvDhC,ERxJH,SAAaH,EAAMC,EAAWC,GAInC,IAHA,IAAIyC,EAAc1C,EACZE,EAAsB,KAEb,CAKb,GAHAwC,EAAY1B,WAAY,EACxBd,EAAoBK,KAAKmC,GAErBA,IAAgBzC,EAClB,OAAOC,EAGT,GAAIoD,EAASvD,EAAM2C,GACjBA,EAAc3C,EAAK2C,EAAYjD,IAAM,GAAGiD,EAAYxD,UAC/C,GAAIsE,EAAWzD,EAAM2C,GAC1BA,EAAc3C,EAAK2C,EAAYjD,KAAKiD,EAAYxD,IAAM,QACjD,GAAIwE,EAAY3D,EAAM2C,GAC3BA,EAAc3C,EAAK2C,EAAYjD,IAAM,GAAGiD,EAAYxD,UAC/C,GAAI0E,EAAU7D,EAAM2C,GACzBA,EAAc3C,EAAK2C,EAAYjD,KAAKiD,EAAYxD,IAAM,OAGnD,KAAI4E,EAAe/D,EAAMG,GAAqB,GAIjD,OADAW,QAAQC,IAAI,UACLZ,EAHPwC,EAAcoB,EAAe/D,EAAMG,GAAqB,KQgI9BoH,CAAIvH,EAAMC,EAAWC,GAC3C0G,ER9CH,SAAwC1G,GAG7C,IAFA,IAAM0G,EAA2B,GAC7BjE,EAAczC,EACK,OAAhByC,GACLiE,EAAyBM,QAAQvE,GACjCA,EAAcA,EAAYhB,aAE5B,OAAOiF,EQuC4BY,CAA+BtH,GAChEjB,KAAKmI,gBAAgBjH,EAAqByG,EAA0BK,K,0BAGtE,SAAazC,GACX,IAAIyC,EAAO,GACE,SAAVzC,EACDyC,EAAO,GAES,YAAVzC,EACNyC,EAAO,GAES,SAAVzC,IACNyC,EAAO,KAET,IAAOjH,EAAQf,KAAKqF,MAAbtE,KACDC,EAAYD,EAAKf,KAAKqF,MAAM8B,cAAcnH,KAAKqF,MAAM+B,cACrDnG,EAAaF,EAAKf,KAAKqF,MAAMpC,eAAejD,KAAKqF,MAAMnC,eACvDhC,EP3KH,SAAaH,EAAMC,EAAWC,GACnC,IAAIyC,EAAc1C,EAClBA,EAAUgB,WAAY,EACtB,IAAMd,EAAsB,GACtBiE,EAAY,GAGlB,IAFAA,EAAU5D,KAAKP,KAMb,GAHAa,QAAQC,IAAI4B,KACZA,EAAcyB,EAAUvD,SAERvB,OAAhB,CAOA,GAHAqD,EAAY1B,WAAY,EACxBd,EAAoBK,KAAKmC,GAGF,IAArByB,EAAU1D,QACViC,IAAgB1C,IACfgE,EAAWjE,EAAM2C,GAElB,OAAOxC,EAGT,GAAIwC,IAAgBzC,EAClB,OAAOC,EAGTgE,EAAsBnE,EAAMoE,EAAWzB,IO6IX8E,CAAIzH,EAAMC,EAAWC,GAC3C0G,EP5DH,SAAwC1G,GAG7C,IAFA,IAAM0G,EAA2B,GAC7BjE,EAAczC,EACK,OAAhByC,GACLiE,EAAyBM,QAAQvE,GACjCA,EAAcA,EAAYhB,aAE5B,OAAOiF,EOqD4Bc,CAA+BxH,GAChEjB,KAAKmI,gBAAgBjH,EAAqByG,EAA0BK,K,wBAItE,SAAWT,EAASmB,GAGlB,IAAIC,EAAYC,IAEhB,GAAY,UAATF,EAAH,CA8BA,IAAI,IAAI3D,EAAI,EAAGA,EAAI,KAAMA,EACvB,IAAI,IAAI8D,EAAI,EAAGA,EAAI,KAAMA,EAAE,CACzB,IAAInF,EAAc6D,EAAQxC,GAAG8D,GAe7B,GAdGnF,EAAYvD,UACb2H,SAASC,eAAT,eAAgCrE,EAAYjD,IAA5C,YAAmDiD,EAAYxD,MAAOU,UACtE,mBACA+H,EAAU5D,GAAG8D,GAAG1I,UAAW,GAErBuD,EAAYtD,SAClB0H,SAASC,eAAT,eAAgCrE,EAAYjD,IAA5C,YAAmDiD,EAAYxD,MAAOU,UACtE,kBACA+H,EAAU5D,GAAG8D,GAAGzI,SAAU,GAG1B0H,SAASC,eAAT,eAAgCrE,EAAYjD,IAA5C,YAAmDiD,EAAYxD,MAAOU,UACtE,YAEU,SAAT8H,GAAmBhF,EAAYrD,OAAO,CACvC,IAAM0D,EAAO,2BACR4E,EAAU5D,GAAG8D,IADL,IAEXxI,QAAQ,IAEVsI,EAAU5D,GAAG8D,GAAK9E,EAClB+D,SAASC,eAAT,eAAgCrE,EAAYjD,IAA5C,YAAmDiD,EAAYxD,MAAOU,UACtE,kBAKNZ,KAAKwF,SAAS,CAACzE,KAAM4H,QA3DrB,CACEA,EAAYrB,IACZ,IAAI,IAAIvC,EAAI,EAAGA,EAAI,KAAMA,EACvB,IAAI,IAAI8D,EAAI,EAAGA,EAAI,KAAMA,EAAE,CACzB,IAAInF,EAAciF,EAAU5D,GAAG8D,GAC5BnF,EAAYvD,UACb2H,SAASC,eAAT,eAAgCrE,EAAYjD,IAA5C,YAAmDiD,EAAYxD,MAAOU,UACtE,mBACA+H,EAAU5D,GAAG8D,GAAG1I,UAAW,EAC3BH,KAAKwF,SAAS,CAACvC,cAtLH,KAuLZjD,KAAKwF,SAAS,CAACtC,cAtLH,MAwLNQ,EAAYtD,SAClB0H,SAASC,eAAT,eAAgCrE,EAAYjD,IAA5C,YAAmDiD,EAAYxD,MAAOU,UACtE,kBACA+H,EAAU5D,GAAG8D,GAAGzI,SAAU,EAC1BJ,KAAKwF,SAAS,CAAC2B,aA/LJ,KAgMXnH,KAAKwF,SAAS,CAAC4B,aA/LJ,MAkMXU,SAASC,eAAT,eAAgCrE,EAAYjD,IAA5C,YAAmDiD,EAAYxD,MAAOU,UACtE,YAKNZ,KAAKwF,SAAS,CAACzE,KAAM4H,O,oBAqCzB,WAAU,IAAD,OACP,EAA+B3I,KAAKqF,MAA7BtE,EAAP,EAAOA,KAAMiG,EAAb,EAAaA,eAEb,OACE,qCACE,cAAC,EAAD,CAAQtB,eAAgB1F,KAAK0F,eAAgBD,kBAAmBzF,KAAKyF,kBAAmBG,aAAc5F,KAAK4F,aAAcD,aAAc3F,KAAK2F,aAC5IN,MAAOrF,KAAKqF,MAAO8C,gBAAiBnI,KAAKmI,gBAAiBN,oBAAqB7H,KAAK6H,oBAAqBtB,WAAYvG,KAAKuG,WAAYe,eAAgBA,EACtJsB,uBAAwBA,EAAwBE,WAAYA,IAS5D,qBAAKlI,UAAU,OAAf,SACGG,EAAKgI,KAAI,SAACtI,EAAKuI,GACd,OACE,8BACGvI,EAAIsI,KAAI,SAACzH,EAAM2H,GACd,IAAOxI,EAAuCa,EAAvCb,IAAKP,EAAkCoB,EAAlCpB,IAAwBG,GAAUiB,EAA7BnB,SAA6BmB,EAAnBlB,QAAmBkB,EAAVjB,QACpC,OACE,cAAC,EAAD,CAEEH,IAAKA,EACLC,SAAUM,IAAQ,EAAK4E,MAAMpC,eAAiB/C,IAAQ,EAAKmF,MAAMnC,cACjE9C,QAASK,IAAQ,EAAK4E,MAAM8B,cAAgBjH,IAAQ,EAAKmF,MAAM+B,aAC/D/G,OAAQA,EACR2G,eAAgBA,EAChB1G,YAAa,SAACG,EAAKP,GAAN,OAAc,EAAKgJ,gBAAgBzI,EAAKP,IACrDK,aAAc,SAACE,EAAKP,GAAN,OACZ,EAAKiJ,iBAAiB1I,EAAKP,IAE7BM,UAAW,kBAAM,EAAK4I,iBACtB3I,IAAKA,GAXAwI,OALHD,e,GA5P2BnI,cAwR7CyG,EAAiB,WAErB,IADA,IAAMvG,EAAO,GACJN,EAAM,EAAGA,EAAM,GAAIA,IAAO,CAEjC,IADA,IAAM4I,EAAa,GACVnJ,EAAM,EAAGA,EAAM,GAAIA,IAC1BmJ,EAAW9H,KAAKuH,EAAW5I,EAAKO,IAElCM,EAAKQ,KAAK8H,GAGZ,OADAxH,QAAQC,IAAI,kBACLf,GAIH6H,EAAyB,WAE7B,IADA,IAAM7H,EAAO,GACJN,EAAM,EAAGA,EAAM,GAAIA,IAAO,CAEjC,IADA,IAAM4I,EAAa,GACVnJ,EAAM,EAAGA,EAAM,GAAIA,IAC1BmJ,EAAW9H,KAAK+H,EAAmBpJ,EAAKO,IAE1CM,EAAKQ,KAAK8H,GAGZ,OADAxH,QAAQC,IAAI,kBACLf,GAGHuI,EAAqB,SAACpJ,EAAKO,GAC/B,MAAO,CACLP,MACAO,MACAL,SAAS,EACTD,UAAU,EACVgB,SAAUY,IACVC,WAAW,EACX3B,QAAQ,EACRqC,aAAc,OAIZoG,EAAa,SAAC5I,EAAKO,GACvB,MAAO,CACLP,MACAO,MACAL,QAzUmB,KAyUVK,GAxUU,KAwUgBP,EACnCC,SAxUoB,KAwUVM,GAvUU,KAuUiBP,EACrCiB,SAAUY,IACVC,WAAW,EACX3B,QAAQ,EACRqC,aAAc,OAIZ8E,EAA4B,SAACzG,EAAMN,EAAKP,GAC5C,IAAMqH,EAAUxG,EAAKwI,QACfjI,EAAOiG,EAAQ9G,GAAKP,GACpBsJ,EAAO,2BACRlI,GADQ,IAEXjB,QAASiB,EAAKjB,SAGhB,OADAkH,EAAQ9G,GAAKP,GAAOsJ,EACbjC,GAGHE,EAAwB,SAAC1G,EAAMN,EAAKP,GAGxC,IAFA,IAAMqH,EAAUxG,EAAKwI,QACfjI,EAAOiG,EAAQ9G,GAAKP,GACjB6E,EAAI,EAAGA,EAAI,KAAMA,EACxB,IAAI,IAAI8D,EAAI,EAAGA,EAAI,KAAMA,EAAE,CACzB,IAAM9E,EAAO,2BACRhD,EAAKgE,GAAG8D,IADA,IAEXpI,IAAKsE,EACL7E,IAAK2I,EACL1I,UAAU,IAEZoH,EAAQxC,GAAG8D,GAAK9E,EAIpB,IAAMyF,EAAO,2BACRlI,GADQ,IAEXnB,UAAU,IAGZ,OADAoH,EAAQ9G,GAAKP,GAAOsJ,EACbjC,GAGHG,EAA0B,SAAC3G,EAAMN,EAAKP,GAI1C,IAHA,IAAMqH,EAAUxG,EAAKwI,QACfjI,EAAOiG,EAAQ9G,GAAKP,GAEjB6E,EAAI,EAAGA,EAAI,KAAMA,EACxB,IAAI,IAAI8D,EAAI,EAAGA,EAAI,KAAMA,EAAE,CACzB,IAAM9E,EAAO,2BACRhD,EAAKgE,GAAG8D,IADA,IAEXpI,IAAKsE,EACL7E,IAAK2I,EACLzI,SAAS,IAEXmH,EAAQxC,GAAG8D,GAAK9E,EAIpB,IAAMyF,EAAO,2BACRlI,GADQ,IAEXlB,SAAS,IAGX,OADAmH,EAAQ9G,GAAKP,GAAOsJ,EACbjC,G,MClYMkC,MAbf,SAAexJ,GACX,OAAQA,EAAMyJ,QACV,qBAAK9I,UAAU,QAAf,SACI,sBAAKA,UAAU,cAAf,UACKX,EAAM0J,SACP,wBAAQ/I,UAAU,YAAYkF,QAAS,kBAAM7F,EAAM2J,YAAW,IAA9D,mBACA,wBAAQhJ,UAAU,WAAWkF,QAAS,kBAAM7F,EAAM4J,QAAQ5J,EAAM6J,KAAO,IAAvE,kBACA,wBAAQlJ,UAAU,WAAWkF,QAAS,kBAAM7F,EAAM4J,QAAQ5J,EAAM6J,KAAO,IAAvE,uBAGR,ICGOC,MAbf,SAAwB9J,GACpB,OAAQA,EAAMyJ,QACV,qBAAK9I,UAAU,QAAf,SACI,sBAAKA,UAAU,cAAf,UACKX,EAAM0J,SACP,wBAAQ/I,UAAU,YAAYkF,QAAS,kBAAM7F,EAAM2J,YAAW,IAA9D,mBACA,wBAAQhJ,UAAU,WAAWkF,QAAS,kBAAM7F,EAAM4J,QAAQ5J,EAAM6J,KAAO,IAAvE,oBACA,wBAAQlJ,UAAU,WAAWkF,QAAS,kBAAM7F,EAAM4J,QAAQ5J,EAAM6J,KAAO,IAAvE,uBAGR,ICEOE,MAbf,SAAe/J,GAEX,OACI,qCACI,mEACA,yGACA,qBAAKuG,ICTF,qoGDSkBE,IAAI,kBEQtBuD,MAff,SAAehK,GAEX,OACI,qCACI,yDACA,yGAGA,qBAAKuG,IAAI,6DAA6DE,IAAI,aAAawD,MAAM,cCY1FC,MApBf,SAAelK,GAEX,OACI,qCACI,8CACA,0JAIA,6KAIA,qBAAKuG,IAAI,6DAA6DE,IAAI,aAAawD,MAAM,cCU1FE,MArBf,SAAenK,GAEX,OACI,qCACI,8DACA,uDAAyB,oBAAIW,UAAU,aAAd,kFAEzB,gDAAkB,oBAAIA,UAAU,aAAd,iKAGlB,sEAAwC,oBAAIA,UAAU,aAAd,8JAGxC,qEAAuC,oBAAIA,UAAU,aAAd,iGCCpCyJ,MAhBf,SAAepK,GAEX,OACI,qCACI,0DACA,kJAIA,qBAAKuG,IAAI,6DAA6DE,IAAI,aAAawD,MAAM,cCqE1FI,MArEf,WACE,MAAoCC,oBAAS,GAA7C,mBAAOC,EAAP,KAAmBC,EAAnB,KACA,EAAwBF,mBAAS,GAAjC,mBAAOT,EAAP,KAAaD,EAAb,KAQA,OANAa,qBAAU,WACR9C,YAAW,WACT6C,GAAc,KACb,OACF,IAES,IAATX,EAEC,sBAAKlJ,UAAU,MAAf,UACE,cAAC,EAAD,CAAO8I,QAASc,EAAYZ,WAAYa,EAAeZ,QAASA,EAASC,KAAMA,EAA/E,SACE,cAAC,EAAD,MAEF,cAAC,EAAD,OAIW,IAATA,EAEJ,sBAAKlJ,UAAU,MAAf,UACE,cAAC,EAAD,CAAO8I,QAASc,EAAYZ,WAAYa,EAAeZ,QAASA,EAASC,KAAMA,EAA/E,SACE,cAAC,EAAD,MAEF,cAAC,EAAD,OAIW,IAATA,EAEJ,sBAAKlJ,UAAU,MAAf,UACE,cAAC,EAAD,CAAO8I,QAASc,EAAYZ,WAAYa,EAAeZ,QAASA,EAASC,KAAMA,EAA/E,SACE,cAAC,EAAD,MAEF,cAAC,EAAD,OAIW,IAATA,EAEJ,sBAAKlJ,UAAU,MAAf,UACE,cAAC,EAAD,CAAO8I,QAASc,EAAYZ,WAAYa,EAAeZ,QAASA,EAASC,KAAMA,EAA/E,SACE,cAAC,EAAD,MAEF,cAAC,EAAD,OAIW,IAATA,EAEJ,sBAAKlJ,UAAU,MAAf,UACE,cAAC,EAAD,CAAY8I,QAASc,EAAYZ,WAAYa,EAAeZ,QAASA,EAASC,KAAMA,EAApF,SACE,cAAC,EAAD,MAEF,cAAC,EAAD,OAIW,IAATA,GAAuB,IAATA,EAElB,qBAAKlJ,UAAU,MAAf,SACE,cAAC,EAAD,WAHD,GC3DQ+J,GAZS,SAAAC,GAClBA,GAAeA,aAAuBC,UACxC,6BAAqBC,MAAK,YAAkD,IAA/CC,EAA8C,EAA9CA,OAAQC,EAAsC,EAAtCA,OAAQC,EAA8B,EAA9BA,OAAQC,EAAsB,EAAtBA,OAAQC,EAAc,EAAdA,QAC3DJ,EAAOH,GACPI,EAAOJ,GACPK,EAAOL,GACPM,EAAON,GACPO,EAAQP,OCDdQ,IAASC,OACP,cAAC,IAAMC,WAAP,UACE,cAAC,EAAD,MAEFxD,SAASC,eAAe,SAM1B4C,O","file":"static/js/main.988a054a.chunk.js","sourcesContent":["import React, {Component} from 'react';\r\n\r\nimport './Node.css';\r\n\r\nexport default class Node extends Component {\r\n  render() {\r\n    const {\r\n      col,\r\n      isFinish,\r\n      isStart,\r\n      isWall,\r\n      onMouseDown,\r\n      onMouseEnter,\r\n      onMouseUp,\r\n      row,\r\n    } = this.props;\r\n    const extraClassName = isFinish\r\n      ? 'node-finish'\r\n      : isStart\r\n      ? 'node-start'\r\n      : isWall\r\n      ? 'node-wall'\r\n      : '';\r\n\r\n    return (\r\n      <div\r\n        id={`node-${row}-${col}`}\r\n        className={`node ${extraClassName}`}\r\n        onMouseDown={() => onMouseDown(row, col)}\r\n        onMouseEnter={() => onMouseEnter(row, col)}\r\n        onMouseUp={() => onMouseUp()}></div>\r\n    );\r\n  }\r\n}","// Performs Dijkstra's algorithm; returns *all* nodes in the order\r\n// in which they were visited. Also makes nodes point back to their\r\n// previous node, effectively allowing us to compute the shortest path\r\n// by backtracking from the finish node.\r\nexport function dijkstra(grid, startNode, finishNode) {\r\n  const visitedNodesInOrder = [];\r\n  // Attributes like .distance can be defined randomly and don't need to be initially apart of the object\r\n  startNode.distance = 0;\r\n  const unvisitedNodes = getAllNodes(grid);\r\n  //console.log(unvisitedNodes);\r\n  while (unvisitedNodes.length) {\r\n    sortNodesByDistance(unvisitedNodes);\r\n    const closestNode = unvisitedNodes.shift();\r\n    console.log(closestNode.distance);\r\n    // If we encounter a wall, we skip it.\r\n    if (closestNode.isWall) continue;\r\n    // If the closest node is at a distance of infinity,\r\n    // we must be trapped and should therefore stop.\r\n    if (closestNode.distance === Infinity) return visitedNodesInOrder;\r\n    closestNode.isVisited = true;\r\n    visitedNodesInOrder.push(closestNode);\r\n    if (closestNode === finishNode) return visitedNodesInOrder;\r\n    updateUnvisitedNeighbors(closestNode, grid);\r\n  }\r\n}\r\n\r\nfunction sortNodesByDistance(unvisitedNodes) {\r\n  unvisitedNodes.sort((nodeA, nodeB) => nodeA.distance - nodeB.distance);\r\n  //console.log(unvisitedNodes);\r\n}\r\n\r\nfunction updateUnvisitedNeighbors(node, grid) {\r\n  const unvisitedNeighbors = getUnvisitedNeighbors(node, grid);\r\n  for (const neighbor of unvisitedNeighbors) {\r\n    neighbor.distance = node.distance + 1;\r\n    neighbor.previousNode = node;\r\n  }\r\n}\r\n\r\nfunction getUnvisitedNeighbors(node, grid) {\r\n  const neighbors = [];\r\n  const { col, row } = node;\r\n  if (row > 0) neighbors.push(grid[row - 1][col]);\r\n  if (row < grid.length - 1) neighbors.push(grid[row + 1][col]);\r\n  if (col > 0) neighbors.push(grid[row][col - 1]);\r\n  if (col < grid[0].length - 1) neighbors.push(grid[row][col + 1]);\r\n\r\n  return neighbors.filter((neighbor) => !neighbor.isVisited);\r\n}\r\n\r\nfunction getAllNodes(grid) {\r\n  const nodes = [];\r\n  for (const row of grid) {\r\n    for (const node of row) {\r\n      nodes.push(node);\r\n    }\r\n  }\r\n  return nodes;\r\n}\r\n\r\n// Backtracks from the finishNode to find the shortest path.\r\n// Only works when called *after* the dijkstra method above.\r\nexport function getNodesInShortestPathOrder(finishNode) {\r\n  const nodesInShortestPathOrder = [];\r\n  let currentNode = finishNode;\r\n  while (currentNode !== null) {\r\n    nodesInShortestPathOrder.unshift(currentNode);\r\n    currentNode = currentNode.previousNode;\r\n  }\r\n  return nodesInShortestPathOrder;\r\n}\r\n","// G cost = Distance from starting node\r\n// H cost = Distance from end node\r\n// F cost = G cost + H cost\r\n\r\nexport function Astar(grid, startNode, finishNode) {\r\n  const exploredNodes = [];\r\n  const visitedNodesInOrder = [];\r\n  startNode.Fcost = 0;\r\n  startNode.Gcost = 0;\r\n  exploredNodes.push(startNode);\r\n\r\n  while (1 === 1) {\r\n    // Sort all visted nodes by F cost\r\n    sortNodesByFcost(exploredNodes);\r\n\r\n    // Get the closest node by F cost\r\n    const currentNode = exploredNodes.shift();\r\n    console.log(currentNode);\r\n    // Skip if current node is a wall\r\n    if (typeof currentNode === \"undefined\" || currentNode.isWall) {\r\n      continue;\r\n    }\r\n\r\n    currentNode.isVisited = true;\r\n    visitedNodesInOrder.push(currentNode);\r\n    if (currentNode === finishNode) {\r\n      return visitedNodesInOrder;\r\n    }\r\n\r\n    // Explore nodes function\r\n    exploreNodes(currentNode, startNode, finishNode, exploredNodes, grid);\r\n  }\r\n}\r\n\r\nfunction updateExploredNodes(exploredNodes, nodeToRemove) {\r\n  if (nodeToRemove.isWall) {\r\n    return exploredNodes;\r\n  }\r\n\r\n  return exploredNodes.filter((node) => !nodeToRemove);\r\n}\r\n\r\nfunction calculateHcost(nodeRow, nodeCol, finishNodeRow, finishNodeCol) {\r\n  const y_diff_squared = Math.pow(Math.abs(nodeRow - finishNodeRow), 2);\r\n  const x_diff_squared = Math.pow(Math.abs(nodeCol - finishNodeCol), 2);\r\n  const H_cost = Math.sqrt(y_diff_squared + x_diff_squared) * 10;\r\n  return H_cost;\r\n}\r\n\r\nfunction calculateGcost(currentNode, diagonal) {\r\n  var G_cost = currentNode.Gcost;\r\n\r\n  if (diagonal) {\r\n    G_cost += Math.sqrt(2) * 10;\r\n  } else {\r\n    G_cost += 10;\r\n  }\r\n\r\n  return G_cost;\r\n}\r\n\r\nfunction exploreNodes(currentNode, startNode, finishNode, exploredNodes, grid) {\r\n  // Loop through all the nodes around the current node and calculate the G, H and F costs\r\n  const { row, col } = currentNode;\r\n\r\n  // Explore node above\r\n  if (row > 0) {\r\n    const diagonal = false;\r\n    const oldNode = grid[row - 1][col];\r\n    const node = grid[row - 1][col];\r\n\r\n    const previousGcost = node.Gcost;\r\n    node.Gcost = calculateGcost(currentNode, diagonal);\r\n\r\n    node.Hcost = calculateHcost(row - 1, col, finishNode.row, finishNode.col);\r\n    if (node.Gcost < previousGcost) {\r\n      exploredNodes = updateExploredNodes(exploredNodes, oldNode);\r\n      node.isExplored = false;\r\n    } else {\r\n      if (previousGcost != null) {\r\n        node.Gcost = previousGcost;\r\n      }\r\n    }\r\n    const Fcost = node.Hcost + node.Gcost;\r\n    node.Fcost = Fcost;\r\n    if (!node.isExplored && !node.isWall) {\r\n      node.isExplored = true;\r\n      exploredNodes.push(node);\r\n      node.previousNode = currentNode;\r\n    }\r\n  }\r\n\r\n  // Explore node below\r\n  if (row < grid.length - 1) {\r\n    const diagonal = false;\r\n    const oldNode = grid[row + 1][col];\r\n    const node = grid[row + 1][col];\r\n    const previousGcost = node.Gcost;\r\n    node.Gcost = calculateGcost(currentNode, diagonal);\r\n    node.Hcost = calculateHcost(row + 1, col, finishNode.row, finishNode.col);\r\n    if (node.Gcost < previousGcost) {\r\n      exploredNodes = updateExploredNodes(exploredNodes, oldNode);\r\n      node.isExplored = false;\r\n    } else {\r\n      if (previousGcost != null) {\r\n        node.Gcost = previousGcost;\r\n      }\r\n    }\r\n    const Fcost = node.Hcost + node.Gcost;\r\n    node.Fcost = Fcost;\r\n    if (!node.isExplored && !node.isWall) {\r\n      node.isExplored = true;\r\n      exploredNodes.push(node);\r\n      node.previousNode = currentNode;\r\n    }\r\n  }\r\n\r\n  // Explore node to the left\r\n  if (col > 0) {\r\n    const diagonal = false;\r\n    const oldNode = grid[row][col - 1];\r\n    const node = grid[row][col - 1];\r\n    const previousGcost = node.Gcost;\r\n    node.Gcost = calculateGcost(currentNode, diagonal);\r\n    node.Hcost = calculateHcost(row, col - 1, finishNode.row, finishNode.col);\r\n    if (node.Gcost < previousGcost) {\r\n      exploredNodes = updateExploredNodes(exploredNodes, oldNode);\r\n      node.isExplored = false;\r\n    } else {\r\n      if (previousGcost != null) {\r\n        node.Gcost = previousGcost;\r\n      }\r\n    }\r\n    const Fcost = node.Hcost + node.Gcost;\r\n    node.Fcost = Fcost;\r\n    if (!node.isExplored && !node.isWall) {\r\n      node.isExplored = true;\r\n      exploredNodes.push(node);\r\n      node.previousNode = currentNode;\r\n    }\r\n  }\r\n\r\n  // Explore node to the right\r\n  if (col < grid[0].length - 1) {\r\n    const diagonal = false;\r\n    const oldNode = grid[row][col + 1];\r\n    const node = grid[row][col + 1];\r\n    const previousGcost = node.Gcost;\r\n    node.Gcost = calculateGcost(currentNode, diagonal);\r\n    node.Hcost = calculateHcost(row, col + 1, finishNode.row, finishNode.col);\r\n    if (node.Gcost < previousGcost) {\r\n      exploredNodes = updateExploredNodes(exploredNodes, oldNode);\r\n      node.isExplored = false;\r\n    } else {\r\n      if (previousGcost != null) {\r\n        node.Gcost = previousGcost;\r\n      }\r\n    }\r\n    const Fcost = node.Hcost + node.Gcost;\r\n    node.Fcost = Fcost;\r\n    if (!node.isExplored && !node.isWall) {\r\n      node.isExplored = true;\r\n      exploredNodes.push(node);\r\n      node.previousNode = currentNode;\r\n    }\r\n  }\r\n\r\n  // Explore node diagonally top left\r\n  if (row > 0 && col > 0) {\r\n    const diagonal = true;\r\n    const oldNode = grid[row - 1][col - 1];\r\n    const node = grid[row - 1][col - 1];\r\n    const previousGcost = node.Gcost;\r\n    node.Gcost = calculateGcost(currentNode, diagonal);\r\n    node.Hcost = calculateHcost(\r\n      row - 1,\r\n      col - 1,\r\n      finishNode.row,\r\n      finishNode.col\r\n    );\r\n    if (node.Gcost < previousGcost) {\r\n      exploredNodes = updateExploredNodes(exploredNodes, oldNode);\r\n      node.isExplored = false;\r\n    } else {\r\n      if (previousGcost != null) {\r\n        node.Gcost = previousGcost;\r\n      }\r\n    }\r\n    const Fcost = node.Hcost + node.Gcost;\r\n    node.Fcost = Fcost;\r\n    if (!node.isExplored && !node.isWall) {\r\n      node.isExplored = true;\r\n      exploredNodes.push(node);\r\n      node.previousNode = currentNode;\r\n    }\r\n  }\r\n\r\n  // Explore node diagonally top right\r\n  if (row > 0 && col < grid[0].length - 1) {\r\n    const diagonal = true;\r\n    const oldNode = grid[row - 1][col + 1];\r\n    const node = grid[row - 1][col + 1];\r\n    const previousGcost = node.Gcost;\r\n    node.Gcost = calculateGcost(currentNode, diagonal);\r\n    node.Hcost = calculateHcost(\r\n      row - 1,\r\n      col + 1,\r\n      finishNode.row,\r\n      finishNode.col\r\n    );\r\n    if (node.Gcost < previousGcost) {\r\n      exploredNodes = updateExploredNodes(exploredNodes, oldNode);\r\n      node.isExplored = false;\r\n    } else {\r\n      if (previousGcost != null) {\r\n        node.Gcost = previousGcost;\r\n      }\r\n    }\r\n    const Fcost = node.Hcost + node.Gcost;\r\n    node.Fcost = Fcost;\r\n    if (!node.isExplored && !node.isWall) {\r\n      node.isExplored = true;\r\n      exploredNodes.push(node);\r\n      node.previousNode = currentNode;\r\n    }\r\n  }\r\n\r\n  // Explore node diagonally bottom left\r\n  if (row < grid.length - 1 && col > 0) {\r\n    const diagonal = true;\r\n    const oldNode = grid[row + 1][col - 1];\r\n    const node = grid[row + 1][col - 1];\r\n    const previousGcost = node.Gcost;\r\n    node.Gcost = calculateGcost(currentNode, diagonal);\r\n    node.Hcost = calculateHcost(\r\n      row + 1,\r\n      col - 1,\r\n      finishNode.row,\r\n      finishNode.col\r\n    );\r\n    if (node.Gcost < previousGcost) {\r\n      exploredNodes = updateExploredNodes(exploredNodes, oldNode);\r\n      node.isExplored = false;\r\n    } else {\r\n      if (previousGcost != null) {\r\n        node.Gcost = previousGcost;\r\n      }\r\n    }\r\n    const Fcost = node.Hcost + node.Gcost;\r\n    node.Fcost = Fcost;\r\n    if (!node.isExplored && !node.isWall) {\r\n      node.isExplored = true;\r\n      exploredNodes.push(node);\r\n      node.previousNode = currentNode;\r\n    }\r\n  }\r\n\r\n  // Explore node diagonally bottom right\r\n  if (row < grid.length - 1 && col < grid[0].length - 1) {\r\n    const diagonal = true;\r\n    const oldNode = grid[row + 1][col + 1];\r\n    const node = grid[row + 1][col + 1];\r\n    const previousGcost = node.Gcost;\r\n    node.Gcost = calculateGcost(currentNode, diagonal);\r\n    node.Hcost = calculateHcost(\r\n      row + 1,\r\n      col + 1,\r\n      finishNode.row,\r\n      finishNode.col\r\n    );\r\n    if (node.Gcost < previousGcost) {\r\n      exploredNodes = updateExploredNodes(exploredNodes, oldNode);\r\n      node.isExplored = false;\r\n    } else {\r\n      if (previousGcost != null) {\r\n        node.Gcost = previousGcost;\r\n      }\r\n    }\r\n    const Fcost = node.Hcost + node.Gcost;\r\n    node.Fcost = Fcost;\r\n    if (!node.isExplored && !node.isWall) {\r\n      node.isExplored = true;\r\n      exploredNodes.push(node);\r\n      node.previousNode = currentNode;\r\n    }\r\n  }\r\n}\r\n\r\nfunction sortNodesByFcost(exploredNodes) {\r\n  exploredNodes.sort((nodeA, nodeB) =>\r\n    nodeA.Fcost === nodeB.Fcost\r\n      ? nodeA.H_cost - nodeB.Hcost\r\n      : nodeA.Fcost - nodeB.Fcost\r\n  );\r\n}\r\n\r\n// Backtracks from the finishNode to find the shortest path.\r\n// Only works when called *after* the dijkstra method above.\r\nexport function getNodesInShortestPathOrderAstar(finishNode) {\r\n  const nodesInShortestPathOrder = [];\r\n  let currentNode = finishNode;\r\n  while (1 == 1) {\r\n    if (currentNode.isStart) {\r\n      nodesInShortestPathOrder.unshift(currentNode);\r\n      break;\r\n    }\r\n    nodesInShortestPathOrder.unshift(currentNode);\r\n    currentNode = currentNode.previousNode;\r\n  }\r\n  return nodesInShortestPathOrder;\r\n}\r\n","// Search order - Top, Right, Bottom, Left\r\n// Search next avaiable node from current node\r\n\r\nexport function DFS(grid, startNode, finishNode) {\r\n  let currentNode = startNode;\r\n  const visitedNodesInOrder = [];\r\n\r\n  while (1 == 1) {\r\n    // Set current Node to visited\r\n    currentNode.isVisited = true;\r\n    visitedNodesInOrder.push(currentNode);\r\n\r\n    if (currentNode === finishNode) {\r\n      return visitedNodesInOrder;\r\n    }\r\n\r\n    if (checkTop(grid, currentNode)) {\r\n      currentNode = grid[currentNode.row - 1][currentNode.col];\r\n    } else if (checkRight(grid, currentNode)) {\r\n      currentNode = grid[currentNode.row][currentNode.col + 1];\r\n    } else if (checkBottom(grid, currentNode)) {\r\n      currentNode = grid[currentNode.row + 1][currentNode.col];\r\n    } else if (checkLeft(grid, currentNode)) {\r\n      currentNode = grid[currentNode.row][currentNode.col - 1];\r\n    }\r\n    // If there are no nodes available to go to, back track to a previous visted node to check if we can back track\r\n    else if (checkBackTrack(grid, visitedNodesInOrder)[0]) {\r\n      currentNode = checkBackTrack(grid, visitedNodesInOrder)[1];\r\n    } else {\r\n      console.log(\"oh boy\");\r\n      return visitedNodesInOrder;\r\n    }\r\n  }\r\n}\r\n\r\nfunction checkTop(grid, currentNode) {\r\n  const { row, col } = currentNode;\r\n  if (row > 0) {\r\n    const topNode = grid[row - 1][col];\r\n    if (!topNode.isVisited && !topNode.isWall) {\r\n      topNode.previousNode = currentNode;\r\n      return true;\r\n    }\r\n  }\r\n\r\n  return false;\r\n}\r\n\r\nfunction checkRight(grid, currentNode) {\r\n  const { row, col } = currentNode;\r\n  if (col < grid[0].length - 1) {\r\n    const rightNode = grid[row][col + 1];\r\n    if (!rightNode.isVisited && !rightNode.isWall) {\r\n      rightNode.previousNode = currentNode;\r\n      return true;\r\n    }\r\n  }\r\n\r\n  return false;\r\n}\r\n\r\nfunction checkBottom(grid, currentNode) {\r\n  const { row, col } = currentNode;\r\n  if (row < grid.length - 1) {\r\n    const bottomNode = grid[row + 1][col];\r\n    if (!bottomNode.isVisited && !bottomNode.isWall) {\r\n      bottomNode.previousNode = currentNode;\r\n      return true;\r\n    }\r\n  }\r\n\r\n  return false;\r\n}\r\n\r\nfunction checkLeft(grid, currentNode) {\r\n  const { row, col } = currentNode;\r\n  if (col > 0) {\r\n    const leftNode = grid[row][col - 1];\r\n    if (!leftNode.isVisited && !leftNode.isWall) {\r\n      leftNode.previousNode = currentNode;\r\n      return true;\r\n    }\r\n  }\r\n\r\n  return false;\r\n}\r\n\r\nfunction checkBackTrack(grid, visitedNodesInOrder) {\r\n  let currentNode = visitedNodesInOrder[visitedNodesInOrder.length - 1];\r\n  let i = 0;\r\n  while (\r\n    i < visitedNodesInOrder.length &&\r\n    !checkTop(grid, currentNode) &&\r\n    !checkRight(grid, currentNode) &&\r\n    !checkBottom(grid, currentNode) &&\r\n    !checkLeft(grid, currentNode)\r\n  ) {\r\n    ++i;\r\n    currentNode = visitedNodesInOrder[visitedNodesInOrder.length - 1 - i];\r\n  }\r\n\r\n  if (i === visitedNodesInOrder.length) {\r\n    return [false, null];\r\n  } else {\r\n    return [true, currentNode];\r\n  }\r\n}\r\n\r\n// Backtracks from the finishNode to find the shortest path.\r\n// Only works when called *after* the dijkstra method above.\r\nexport function getNodesInShortestPathOrderDFS(finishNode) {\r\n  const nodesInShortestPathOrder = [];\r\n  let currentNode = finishNode;\r\n  while (currentNode !== null) {\r\n    nodesInShortestPathOrder.unshift(currentNode);\r\n    currentNode = currentNode.previousNode;\r\n  }\r\n  return nodesInShortestPathOrder;\r\n}\r\n","// Search order - Top, Right, Bottom, Left\r\n// Search next available node frome Queue\r\n\r\nexport function BFS(grid, startNode, finishNode) {\r\n  let currentNode = startNode;\r\n  startNode.isVisited = true;\r\n  const visitedNodesInOrder = [];\r\n  const nodeQueue = [];\r\n  nodeQueue.push(startNode);\r\n\r\n  while (1 === 1) {\r\n    console.log(currentNode);\r\n    currentNode = nodeQueue.shift();\r\n\r\n    if (currentNode.isWall) {\r\n      continue;\r\n    }\r\n\r\n    currentNode.isVisited = true;\r\n    visitedNodesInOrder.push(currentNode);\r\n\r\n    if (\r\n      nodeQueue.length === 0 &&\r\n      currentNode !== startNode &&\r\n      !checkPaths(grid, currentNode)\r\n    ) {\r\n      return visitedNodesInOrder;\r\n    }\r\n\r\n    if (currentNode === finishNode) {\r\n      return visitedNodesInOrder;\r\n    }\r\n\r\n    checkSurroundingNodes(grid, nodeQueue, currentNode);\r\n  }\r\n}\r\n\r\nfunction checkPaths(grid, currentNode) {\r\n  const { row, col } = currentNode;\r\n\r\n  if (row > 0) {\r\n    const topNode = grid[row - 1][col];\r\n    if (!topNode.isVisited && !topNode.isWall && !topNode.inQueue) {\r\n      return true;\r\n    }\r\n  }\r\n\r\n  if (col < grid[0].length - 1) {\r\n    const rightNode = grid[row][col + 1];\r\n    if (!rightNode.isVisited && !rightNode.isWall && !rightNode.inQueue) {\r\n      return true;\r\n    }\r\n  }\r\n\r\n  if (row < grid.length - 1) {\r\n    const bottomNode = grid[row + 1][col];\r\n    if (!bottomNode.isVisited && !bottomNode.isWall && !bottomNode.inQueue) {\r\n      return true;\r\n    }\r\n  }\r\n\r\n  if (col > 0) {\r\n    const leftNode = grid[row][col - 1];\r\n    if (!leftNode.isVisited && !leftNode.isWall && !leftNode.inQueue) {\r\n      return true;\r\n    }\r\n  }\r\n\r\n  return false;\r\n}\r\n\r\nfunction checkSurroundingNodes(grid, nodeQueue, currentNode) {\r\n  const { row, col } = currentNode;\r\n\r\n  if (row > 0) {\r\n    const topNode = grid[row - 1][col];\r\n    if (!topNode.isVisited && !topNode.isWall && !topNode.inQueue) {\r\n      topNode.previousNode = currentNode;\r\n      topNode.inQueue = true;\r\n      nodeQueue.push(topNode);\r\n    }\r\n  }\r\n\r\n  if (col < grid[0].length - 1) {\r\n    const rightNode = grid[row][col + 1];\r\n    if (!rightNode.isVisited && !rightNode.isWall && !rightNode.inQueue) {\r\n      rightNode.previousNode = currentNode;\r\n      rightNode.inQueue = true;\r\n      nodeQueue.push(rightNode);\r\n    }\r\n  }\r\n\r\n  if (row < grid.length - 1) {\r\n    const bottomNode = grid[row + 1][col];\r\n    if (!bottomNode.isVisited && !bottomNode.isWall && !bottomNode.inQueue) {\r\n      bottomNode.previousNode = currentNode;\r\n      bottomNode.inQueue = true;\r\n      nodeQueue.push(bottomNode);\r\n    }\r\n  }\r\n\r\n  if (col > 0) {\r\n    const leftNode = grid[row][col - 1];\r\n    if (!leftNode.isVisited && !leftNode.isWall && !leftNode.inQueue) {\r\n      leftNode.previousNode = currentNode;\r\n      leftNode.inQueue = true;\r\n      nodeQueue.push(leftNode);\r\n    }\r\n  }\r\n\r\n  return false;\r\n}\r\n\r\n// Backtracks from the finishNode to find the shortest path.\r\n// Only works when called *after* the dijkstra method above.\r\nexport function getNodesInShortestPathOrderBFS(finishNode) {\r\n  const nodesInShortestPathOrder = [];\r\n  let currentNode = finishNode;\r\n  while (currentNode !== null) {\r\n    nodesInShortestPathOrder.unshift(currentNode);\r\n    currentNode = currentNode.previousNode;\r\n  }\r\n  return nodesInShortestPathOrder;\r\n}\r\n","export default __webpack_public_path__ + \"static/media/start_node.77aadac8.JPG\";","export default __webpack_public_path__ + \"static/media/finish_node.5dd7f761.JPG\";","export default __webpack_public_path__ + \"static/media/shortest_path_node.59d34767.JPG\";","export default __webpack_public_path__ + \"static/media/visited_node.7f9d4088.JPG\";","export default __webpack_public_path__ + \"static/media/wall_node.e2d98ba4.JPG\";","import React, {Component} from 'react';\r\nimport { useState } from 'react';\r\nimport './Navbar.css';\r\nimport start_node from '../../images/start_node.JPG'\r\nimport finish_node from '../../images/finish_node.JPG'\r\nimport shortest_path_node from '../../images/shortest_path_node.JPG'\r\nimport visited_node from '../../images/visited_node.JPG'\r\nimport wall_node from '../../images/wall_node.JPG'\r\n\r\nexport default class NavBar extends Component{\r\n  constructor(props) {\r\n    super(props);\r\n    this.state = {\r\n      algorithm: 'Visualize',\r\n      speed: 'Fast'\r\n    };\r\n  }\r\n\r\n  selectDijkstra(){\r\n    this.setState({algorithm: 'Visualize Dijkstra'})\r\n  }\r\n\r\n  selectAstar(){\r\n    this.setState({algorithm: 'Visualize A*'})\r\n  }\r\n\r\n  selectDFS(){\r\n    this.setState({algorithm: 'Visualize DFS'})\r\n  }\r\n\r\n  selectBFS(){\r\n    this.setState({algorithm: 'Visualize BFS'})\r\n  }\r\n\r\n  setFast(){\r\n    this.setState({speed: 'Fast'})\r\n  }\r\n\r\n  setAverage(){\r\n    this.setState({speed: 'Average'})\r\n  }\r\n\r\n  setSlow(){\r\n    this.setState({speed: 'Slow'})\r\n  }\r\n\r\n\r\n  visualizeAlgorithm(){\r\n    if(this.state.algorithm === 'Visualize Dijkstra'){\r\n      this.props.visualizeDijkstra(this.state.speed);\r\n    }\r\n    else if(this.state.algorithm === 'Visualize A*'){\r\n      this.props.visualizeAstar(this.state.speed);\r\n    }\r\n    else if(this.state.algorithm === 'Visualize DFS'){\r\n      this.props.visualizeDFS(this.state.speed);\r\n    }\r\n    else if(this.state.algorithm === 'Visualize BFS'){\r\n      this.props.visualizeBFS(this.state.speed);\r\n    }\r\n    else {\r\n      this.setState({algorithm: 'Please select an Algorithm'})\r\n    }\r\n  }\r\n\r\n  render () {\r\n    return (\r\n      <>\r\n      <div className=\"container\">\r\n        <nav className=\"navigation-bar\"> \r\n          <div class=\"dropdown\">\r\n            <button class=\"dropbtn\">Algorithms</button>\r\n            <div id=\"myDropdown\" class=\"dropdown-content\">\r\n              <a onClick={() => this.selectDijkstra()}>Dijkstras Algorithm</a>\r\n              <a onClick={() => this.selectAstar()}>A* Algorithm</a>\r\n              <a onClick={() => this.selectDFS()}>DFS Algorithm</a>\r\n              <a onClick={() => this.selectBFS()}>BFS Algorithm</a>\r\n            </div>\r\n          </div>\r\n          <button className=\"visualize-btn\" onClick={() => this.visualizeAlgorithm()}>{this.state.algorithm}</button>\r\n          <div class=\"dropdown\">\r\n            <button class=\"dropbtn\">Speed: {this.state.speed}</button>\r\n            <div id=\"myDropdown\" class=\"dropdown-content\">\r\n              <a onClick={() => this.setFast()}>Fast</a>\r\n              <a onClick={() => this.setAverage()}>Avergae</a>\r\n              <a onClick={() => this.setSlow()}>Slow</a>\r\n            </div>\r\n          </div>\r\n          <div class=\"dropdown\">\r\n            <button class=\"dropbtn\">Clear</button>\r\n            <div id=\"myDropdown\" class=\"dropdown-content\">\r\n              <a onClick={() => this.props.clearWalls(this.props.state.grid, \"walls\")}>Clear Walls</a>\r\n              <a onClick={() => this.props.clearWalls(this.props.state.grid, \"path\")}>Clear Path</a>\r\n              <a onClick={() => this.props.clearWalls(this.props.state.grid, \"board\")}>Clear Board</a>\r\n            </div>\r\n          </div>\r\n          <div className=\"row\">\r\n            <div className=\"column\">\r\n              <h4>Start Node</h4>\r\n              <img src={start_node} alt=\"Start Node\"/>\r\n            </div>\r\n            <div className=\"column\">\r\n              <h4>Finish Node</h4>\r\n              <img src={finish_node} alt=\"Finish Node\"/>\r\n            </div>\r\n            <div className=\"column\">\r\n              <h4>Wall Node</h4>\r\n              <img src={wall_node} alt=\"Wall Node\"/>\r\n            </div>\r\n            <div className=\"column\">\r\n              <h4>Visted Node</h4>\r\n              <img src={visited_node} alt=\"Visited Node\"/>\r\n            </div>\r\n            <div className=\"column\">\r\n              <h4>Shortest Path Node</h4>\r\n              <img src={shortest_path_node} alt=\"Shortest Path Node\"/>\r\n            </div>\r\n          </div>\r\n        </nav>\r\n      </div>\r\n      </>\r\n    );\r\n  };\r\n};\r\n\r\n","import React, {Component} from 'react';\r\nimport Node from './Node/Node';\r\nimport {dijkstra, getNodesInShortestPathOrder} from '../algorithms/dijkstra';\r\nimport { Astar, getNodesInShortestPathOrderAstar} from '../algorithms/Astar';\r\nimport { DFS, getNodesInShortestPathOrderDFS} from '../algorithms/DFS';\r\nimport { BFS, getNodesInShortestPathOrderBFS} from '../algorithms/BFS';\r\nimport NavBar  from './Navbar/Navbar';\r\n\r\nimport './PathfindingVisualizer.css';\r\n\r\nconst START_NODE_ROW = 15;\r\nconst START_NODE_COL = 19;\r\nconst FINISH_NODE_ROW = 15;\r\nconst FINISH_NODE_COL = 57;\r\n\r\nexport default class PathfindingVisualizer extends Component {\r\n  constructor() {\r\n    super();\r\n    this.state = {\r\n      grid: [],\r\n      mouseIsPressed: false,\r\n      finishNodePressed: false,\r\n      finishNodeRow: FINISH_NODE_ROW,\r\n      finishNodeCol: FINISH_NODE_COL,\r\n      startNodePressed: false,\r\n      startNodeRow: START_NODE_ROW,\r\n      startNodeCol: START_NODE_COL\r\n    };\r\n\r\n    this.clearWalls = this.clearWalls.bind(this);\r\n  }\r\n\r\n  componentDidMount() {\r\n    const grid = getInitialGrid();\r\n    this.setState({grid});\r\n  }\r\n\r\n  handleMouseDown(row, col) {\r\n    if(row === this.state.finishNodeRow && col === this.state.finishNodeCol){\r\n      this.setState({mouseIsPressed: true, finishNodePressed: true});\r\n      return;\r\n    }\r\n    else if(row === this.state.startNodeRow && col === this.state.startNodeCol){\r\n      this.setState({mouseIsPressed: true, startNodePressed: true});\r\n      return;\r\n    }\r\n    const newGrid = getNewGridWithWallToggled(this.state.grid, row, col);\r\n    this.setState({grid: newGrid, mouseIsPressed: true});\r\n  }\r\n\r\n  handleMouseEnter(row, col) {\r\n    if (!this.state.mouseIsPressed){\r\n      return;\r\n    }\r\n    else if(this.state.finishNodePressed){\r\n      const newGrid = getNewGridWithEndNode(this.state.grid, row, col);\r\n      this.setState({finishNodeCol: col, finishNodeRow: row})\r\n      this.setState({grid: newGrid})\r\n    }\r\n    else if(this.state.startNodePressed){\r\n      const newGrid = getNewGridWithStartNode(this.state.grid, row, col);\r\n      this.setState({startNodeCol: col, startNodeRow: row})\r\n      this.setState({grid: newGrid})\r\n    }\r\n    else {\r\n      const newGrid = getNewGridWithWallToggled(this.state.grid, row, col);\r\n      this.setState({grid: newGrid});  \r\n    }\r\n\r\n  }\r\n\r\n  handleMouseUp() {\r\n    this.setState({mouseIsPressed: false, finishNodePressed: false, startNodePressed: false});\r\n  }\r\n\r\n  animateDijkstra(visitedNodesInOrder, nodesInShortestPathOrder, speed) {\r\n    for (let i = 0; i <= visitedNodesInOrder.length; i++) {\r\n      if (i === visitedNodesInOrder.length) {\r\n        setTimeout(() => {\r\n          this.animateShortestPath(nodesInShortestPathOrder);\r\n        }, speed * i);\r\n        return;\r\n      }\r\n      setTimeout(() => {\r\n        console.log(speed);\r\n        const node = visitedNodesInOrder[i];\r\n        document.getElementById(`node-${node.row}-${node.col}`).className =\r\n          'node node-visited';\r\n      }, speed * i);\r\n    }\r\n  }\r\n  \r\n  animateShortestPath(nodesInShortestPathOrder) {\r\n    for (let i = 0; i < nodesInShortestPathOrder.length; i++) {\r\n      setTimeout(() => {\r\n        const node = nodesInShortestPathOrder[i];\r\n        document.getElementById(`node-${node.row}-${node.col}`).className =\r\n          'node node-shortest-path';\r\n      }, 50 * i);\r\n    }\r\n  }\r\n\r\n\r\n  visualizeDijkstra(speed) {\r\n    let rate = 10;\r\n    if(speed === 'Fast'){\r\n      rate = 10;\r\n    }\r\n    else if(speed === 'Average'){\r\n      rate = 50;\r\n    }\r\n    else if(speed === 'Slow'){\r\n      rate = 100;\r\n    }\r\n    const {grid} = this.state;\r\n    const startNode = grid[this.state.startNodeRow][this.state.startNodeCol];\r\n    const finishNode = grid[this.state.finishNodeRow][this.state.finishNodeCol];\r\n    const visitedNodesInOrder = dijkstra(grid, startNode, finishNode);\r\n    const nodesInShortestPathOrder = getNodesInShortestPathOrder(finishNode);\r\n    this.animateDijkstra(visitedNodesInOrder, nodesInShortestPathOrder, rate);\r\n  }\r\n\r\n  visualizeAstar(speed) {\r\n    let rate = 10;\r\n    if(speed === 'Fast'){\r\n      rate = 10;\r\n    }\r\n    else if(speed === 'Average'){\r\n      rate = 50;\r\n    }\r\n    else if(speed === 'Slow'){\r\n      rate = 100;\r\n    }\r\n    const {grid} = this.state;\r\n    const startNode = grid[this.state.startNodeRow][this.state.startNodeCol];\r\n    const finishNode = grid[this.state.finishNodeRow][this.state.finishNodeCol];\r\n    const visitedNodesInOrder = Astar(grid, startNode, finishNode);\r\n    const nodesInShortestPathOrder = getNodesInShortestPathOrderAstar(finishNode);\r\n    this.animateDijkstra(visitedNodesInOrder, nodesInShortestPathOrder, rate);    \r\n  }\r\n\r\n  visualizeDFS(speed) {\r\n    let rate = 10;\r\n    if(speed === 'Fast'){\r\n      rate = 10;\r\n    }\r\n    else if(speed === 'Average'){\r\n      rate = 50;\r\n    }\r\n    else if(speed === 'Slow'){\r\n      rate = 100;\r\n    }\r\n    const {grid} = this.state;\r\n    const startNode = grid[this.state.startNodeRow][this.state.startNodeCol];\r\n    const finishNode = grid[this.state.finishNodeRow][this.state.finishNodeCol];\r\n    const visitedNodesInOrder = DFS(grid, startNode, finishNode);\r\n    const nodesInShortestPathOrder = getNodesInShortestPathOrderDFS(finishNode);\r\n    this.animateDijkstra(visitedNodesInOrder, nodesInShortestPathOrder, rate);    \r\n  }\r\n\r\n  visualizeBFS(speed) {\r\n    let rate = 10;\r\n    if(speed === 'Fast'){\r\n      rate = 10;\r\n    }\r\n    else if(speed === 'Average'){\r\n      rate = 50;\r\n    }\r\n    else if(speed === 'Slow'){\r\n      rate = 100;\r\n    }\r\n    const {grid} = this.state;\r\n    const startNode = grid[this.state.startNodeRow][this.state.startNodeCol];\r\n    const finishNode = grid[this.state.finishNodeRow][this.state.finishNodeCol];\r\n    const visitedNodesInOrder = BFS(grid, startNode, finishNode);\r\n    const nodesInShortestPathOrder = getNodesInShortestPathOrderBFS(finishNode);\r\n    this.animateDijkstra(visitedNodesInOrder, nodesInShortestPathOrder, rate);    \r\n  }\r\n\r\n\r\n  clearWalls(newGrid, type) {\r\n\r\n\r\n    let plainGrid = getInitialGridForClear();\r\n    \r\n    if(type === \"board\"){\r\n      plainGrid = getInitialGrid();\r\n      for(let i = 0; i < 29; ++i){\r\n        for(let j = 0; j < 76; ++j){\r\n          let currentNode = plainGrid[i][j]\r\n          if(currentNode.isFinish){\r\n            document.getElementById(`node-${currentNode.row}-${currentNode.col}`).className =\r\n            'node node-finish';\r\n            plainGrid[i][j].isFinish = true;\r\n            this.setState({finishNodeRow: FINISH_NODE_ROW});\r\n            this.setState({finishNodeCol: FINISH_NODE_COL});\r\n          }\r\n          else if(currentNode.isStart){\r\n            document.getElementById(`node-${currentNode.row}-${currentNode.col}`).className =\r\n            'node node-start';\r\n            plainGrid[i][j].isStart = true;\r\n            this.setState({startNodeRow: START_NODE_ROW});\r\n            this.setState({startNodeCol: START_NODE_COL});\r\n          }\r\n          else{\r\n            document.getElementById(`node-${currentNode.row}-${currentNode.col}`).className =\r\n            'node node';\r\n          }\r\n        }\r\n      }\r\n\r\n      this.setState({grid: plainGrid});\r\n      return;\r\n    }\r\n\r\n    for(let i = 0; i < 29; ++i){\r\n      for(let j = 0; j < 76; ++j){\r\n        let currentNode = newGrid[i][j]\r\n        if(currentNode.isFinish){\r\n          document.getElementById(`node-${currentNode.row}-${currentNode.col}`).className =\r\n          'node node-finish';\r\n          plainGrid[i][j].isFinish = true;\r\n        }\r\n        else if(currentNode.isStart){\r\n          document.getElementById(`node-${currentNode.row}-${currentNode.col}`).className =\r\n          'node node-start';\r\n          plainGrid[i][j].isStart = true;\r\n        }\r\n        else{\r\n          document.getElementById(`node-${currentNode.row}-${currentNode.col}`).className =\r\n          'node node';\r\n        }\r\n        if(type === \"path\" && currentNode.isWall){\r\n          const oldNode = {\r\n            ...plainGrid[i][j],\r\n            isWall: true\r\n          }\r\n          plainGrid[i][j] = oldNode\r\n          document.getElementById(`node-${currentNode.row}-${currentNode.col}`).className =\r\n          'node node-wall';\r\n        }\r\n      }\r\n    } \r\n\r\n    this.setState({grid: plainGrid});\r\n\r\n  }\r\n\r\n  render() {\r\n    const {grid, mouseIsPressed} = this.state;\r\n\r\n    return (\r\n      <>\r\n        <NavBar visualizeAstar={this.visualizeAstar} visualizeDijkstra={this.visualizeDijkstra} visualizeBFS={this.visualizeBFS} visualizeDFS={this.visualizeDFS}\r\n        state={this.state} animateDijkstra={this.animateDijkstra} animateShortestPath={this.animateShortestPath} clearWalls={this.clearWalls} getInitialGrid={getInitialGrid}\r\n        getInitialGridForClear={getInitialGridForClear} createNode={createNode}/>\r\n{/*           <div class=\"dropdown\">\r\n            <button class=\"dropbtn\">Clear</button>\r\n            <div id=\"myDropdown\" class=\"dropdown-content\">\r\n              <a onClick={() => this.clearWalls(this.state.grid, \"walls\")}>Clear Walls</a>\r\n              <a onClick={() => this.clearWalls(this.state.grid, \"path\")}>Clear Path</a>\r\n              <a onClick={() => this.clearWalls(this.state.grid, \"board\")}>Clear Board</a>\r\n            </div>\r\n          </div> */}\r\n        <div className=\"grid\">\r\n          {grid.map((row, rowIdx) => {\r\n            return (\r\n              <div key={rowIdx}>\r\n                {row.map((node, nodeIdx) => {\r\n                  const {row, col, isFinish, isStart, isWall} = node;\r\n                  return (\r\n                    <Node\r\n                      key={nodeIdx}\r\n                      col={col}\r\n                      isFinish={row === this.state.finishNodeRow && col === this.state.finishNodeCol}\r\n                      isStart={row === this.state.startNodeRow && col === this.state.startNodeCol}\r\n                      isWall={isWall}\r\n                      mouseIsPressed={mouseIsPressed}\r\n                      onMouseDown={(row, col) => this.handleMouseDown(row, col)}\r\n                      onMouseEnter={(row, col) =>\r\n                        this.handleMouseEnter(row, col)\r\n                      }\r\n                      onMouseUp={() => this.handleMouseUp()}\r\n                      row={row}></Node>\r\n                  );\r\n                })}\r\n              </div>\r\n            );\r\n          })}\r\n        </div>\r\n      </>\r\n    );\r\n  }\r\n}\r\n\r\nconst getInitialGrid = () => {\r\n  const grid = [];\r\n  for (let row = 0; row < 29; row++) {\r\n    const currentRow = [];\r\n    for (let col = 0; col < 76; col++) {\r\n      currentRow.push(createNode(col, row));\r\n    }\r\n    grid.push(currentRow);\r\n  }\r\n  console.log(\"we return here\")\r\n  return grid;\r\n};\r\n\r\n\r\nconst getInitialGridForClear = () => {\r\n  const grid = [];\r\n  for (let row = 0; row < 29; row++) {\r\n    const currentRow = [];\r\n    for (let col = 0; col < 76; col++) {\r\n      currentRow.push(createNodeForClear(col, row));\r\n    }\r\n    grid.push(currentRow);\r\n  }\r\n  console.log(\"we return here\")\r\n  return grid;\r\n};\r\n\r\nconst createNodeForClear = (col, row) => {\r\n  return {\r\n    col,\r\n    row,\r\n    isStart: false,\r\n    isFinish: false,\r\n    distance: Infinity,\r\n    isVisited: false,\r\n    isWall: false,\r\n    previousNode: null,\r\n  };\r\n};\r\n\r\nconst createNode = (col, row) => {\r\n  return {\r\n    col,\r\n    row,\r\n    isStart: row === START_NODE_ROW && col === START_NODE_COL,\r\n    isFinish: row === FINISH_NODE_ROW && col === FINISH_NODE_COL,\r\n    distance: Infinity,\r\n    isVisited: false,\r\n    isWall: false,\r\n    previousNode: null,\r\n  };\r\n};\r\n\r\nconst getNewGridWithWallToggled = (grid, row, col) => {\r\n  const newGrid = grid.slice();\r\n  const node = newGrid[row][col];\r\n  const newNode = {\r\n    ...node,\r\n    isWall: !node.isWall,\r\n  };\r\n  newGrid[row][col] = newNode;\r\n  return newGrid;\r\n};\r\n\r\nconst getNewGridWithEndNode = (grid, row, col) => {\r\n  const newGrid = grid.slice();\r\n  const node = newGrid[row][col];\r\n  for (var i = 0; i < 29; ++i){\r\n    for(var j = 0; j < 76; ++j){\r\n      const oldNode = {\r\n        ...grid[i][j],\r\n        row: i,\r\n        col: j,\r\n        isFinish: false,\r\n      }\r\n      newGrid[i][j] = oldNode\r\n    }\r\n  }\r\n\r\n  const newNode = {\r\n    ...node,\r\n    isFinish: true,\r\n  };\r\n  newGrid[row][col] = newNode;\r\n  return newGrid;\r\n};\r\n\r\nconst getNewGridWithStartNode = (grid, row, col) => {\r\n  const newGrid = grid.slice();\r\n  const node = newGrid[row][col];\r\n \r\n  for (var i = 0; i < 29; ++i){\r\n    for(var j = 0; j < 76; ++j){\r\n      const oldNode = {\r\n        ...grid[i][j],\r\n        row: i,\r\n        col: j,\r\n        isStart: false,\r\n      }\r\n      newGrid[i][j] = oldNode\r\n    }\r\n  }\r\n\r\n  const newNode = {\r\n    ...node,\r\n    isStart: true,\r\n  };\r\n  newGrid[row][col] = newNode;\r\n  return newGrid;\r\n};\r\n\r\n\r\n","import React from 'react'\r\nimport './Popup.css'\r\n\r\n\r\nfunction Popup(props){\r\n    return (props.trigger) ? (\r\n        <div className=\"popup\">\r\n            <div className=\"popup-inner\">\r\n                {props.children}\r\n                <button className=\"close-btn\" onClick={() => props.setTrigger(false)}>Close</button>\r\n                <button className=\"next-btn\" onClick={() => props.setPage(props.page + 1)}>Next</button>\r\n                <button className=\"back-btn\" onClick={() => props.setPage(props.page - 1)}>Back</button>\r\n            </div>\r\n        </div>\r\n    ) : \"\";\r\n}\r\n\r\nexport default Popup","import React from 'react'\r\nimport './Popup.css'\r\n\r\n\r\nfunction FinalPopupPage(props){\r\n    return (props.trigger) ? (\r\n        <div className=\"popup\">\r\n            <div className=\"popup-inner\">\r\n                {props.children}\r\n                <button className=\"close-btn\" onClick={() => props.setTrigger(false)}>Close</button>\r\n                <button className=\"next-btn\" onClick={() => props.setPage(props.page + 1)}>Finish</button>\r\n                <button className=\"back-btn\" onClick={() => props.setPage(props.page - 1)}>Back</button>\r\n            </div>\r\n        </div>\r\n    ) : \"\";\r\n}\r\n\r\nexport default FinalPopupPage","import React from 'react'\r\nimport pointAtoB from '../images/pointAtoB.png'\r\n\r\nfunction Page1(props){\r\n\r\n    return (\r\n        <>\r\n            <h1>Welcome to Pathfinding Visualizer</h1>\r\n            <h2>These next few slides will walk you through how to use this application</h2>\r\n            <img src={pointAtoB} alt=\"Map image\"/>\r\n        </>\r\n    )\r\n\r\n\r\n}\r\n\r\nexport default Page1","export default \"data:image/png;base64,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\"","import React from 'react'\r\n\r\nfunction Page2(props){\r\n\r\n    return (\r\n        <>\r\n            <h1>Move Start and End Node</h1>\r\n            <h2>Click and drag the start or end node\r\n                to move their location on the grid\r\n            </h2>\r\n            <img src=\"https://media.giphy.com/media/S1i5sMb7IQWMdGStH5/giphy.gif\" alt=\"Grid image\" width=\"800px\"/>\r\n        </>\r\n    )\r\n\r\n\r\n}\r\n\r\nexport default Page2","import React from 'react'\r\n\r\nfunction Page3(props){\r\n\r\n    return (\r\n        <>\r\n            <h1>Create Walls</h1>\r\n            <h2>Click and drag empty grid spaces to \r\n                create walls. To remove walls simply click\r\n                and drag over any grid space with a wall. \r\n            </h2>\r\n            <h3>Walls are spaces on the grid that the pathfinding algorithm\r\n                will not traverse when finding the shortest path between the start\r\n                and end node\r\n            </h3>\r\n            <img src=\"https://media.giphy.com/media/0sjZA1wJnAxB73CIIC/giphy.gif\" alt=\"Grid image\" width=\"650px\"/>\r\n        </>\r\n    )\r\n\r\n\r\n}\r\n\r\nexport default Page3","import React from 'react'\r\nimport './Popup.css'\r\n\r\n\r\nfunction Page4(props){\r\n\r\n    return (\r\n        <>\r\n            <h1>Understanding the Algorithms</h1>\r\n            <h3>Dijkstras Algorithm: <h4 className=\"inner-text\">A classic pathfinding algorithm\r\n                that gurantees the shortest path.</h4></h3>\r\n            <h3>A* Algorithm: <h4 className=\"inner-text\">One of the best pathfinding algorithms\r\n                due to its nature of being skewed toward the end node. This algorithm always\r\n                gurantees the shortest path.</h4></h3>\r\n            <h3>Breath-First-Search(BFS) Algorithm: <h4 className=\"inner-text\">Another classic pathfiniding\r\n                algorithm that visits nodes in order of proximity to the start node. This algorithm\r\n                gurantees the shortest path.</h4></h3>\r\n            <h3>Depth-First-Search(DFS) Algorithm: <h4 className=\"inner-text\">A very poor pathfinding algorithm that does \r\n                not guarantee the shortest path.</h4></h3>                \r\n        </>\r\n    )\r\n\r\n\r\n}\r\n\r\nexport default Page4","import React from 'react'\r\n\r\nfunction Page5(props){\r\n\r\n    return (\r\n        <>\r\n            <h1>Visualizing an Algorithm</h1>\r\n            <h2>After configuring the grid to your liking, select\r\n                an algorithm and speed to visualize the pathfinding procedure. \r\n            </h2>\r\n            \r\n            <img src=\"https://media.giphy.com/media/U0DhXRvAmZqktc52XE/giphy.gif\" alt=\"Grid image\" width=\"650px\"/>\r\n        </>\r\n    )\r\n\r\n\r\n}\r\n\r\nexport default Page5","import \"./App.css\";\nimport PathfindingVisualizer from \"./PathfindingVisualizer/PathfindingVisualizer\";\nimport { useState, useEffect } from \"react\";\nimport Popup from \"./Popup/Popup\";\nimport FinalPopup from \"./Popup/FinalPopupPage\";\nimport Page1 from \"./Popup/Page1\";\nimport Page2 from \"./Popup/Page2\";\nimport Page3 from \"./Popup/Page3\";\nimport Page4 from \"./Popup/Page4\";\nimport Page5 from \"./Popup/Page5\";\n\nfunction App() {\n  const [timedPopup, setTimedPopup] = useState(false);\n  const [page, setPage] = useState(1);\n\n  useEffect(() => {\n    setTimeout(() => {\n      setTimedPopup(true);\n    }, 1000);\n  }, []);\n\n  if(page === 1){\n    return (\n      <div className=\"App\">\n        <Popup trigger={timedPopup} setTrigger={setTimedPopup} setPage={setPage} page={page}>\n          <Page1></Page1>\n        </Popup>\n        <PathfindingVisualizer></PathfindingVisualizer>\n      </div>\n    );\n  }\n  else if(page === 2){\n    return (\n      <div className=\"App\">\n        <Popup trigger={timedPopup} setTrigger={setTimedPopup} setPage={setPage} page={page}>\n          <Page2></Page2>\n        </Popup>\n        <PathfindingVisualizer></PathfindingVisualizer>\n      </div>\n    );\n  }\n  else if(page === 3){\n    return (\n      <div className=\"App\">\n        <Popup trigger={timedPopup} setTrigger={setTimedPopup} setPage={setPage} page={page}>\n          <Page3></Page3>\n        </Popup>\n        <PathfindingVisualizer></PathfindingVisualizer>\n      </div>\n    );\n  }\n  else if(page === 4){\n    return (\n      <div className=\"App\">\n        <Popup trigger={timedPopup} setTrigger={setTimedPopup} setPage={setPage} page={page}>\n          <Page4></Page4>\n        </Popup>\n        <PathfindingVisualizer></PathfindingVisualizer>\n      </div>\n    );\n  }\n  else if(page === 5){\n    return (\n      <div className=\"App\">\n        <FinalPopup trigger={timedPopup} setTrigger={setTimedPopup} setPage={setPage} page={page}>\n          <Page5></Page5>\n        </FinalPopup>\n        <PathfindingVisualizer></PathfindingVisualizer>\n      </div>\n    );\n  }\n  else if(page === 6 || page === 0){\n    return (\n      <div className=\"App\">\n        <PathfindingVisualizer></PathfindingVisualizer>\n      </div>\n    );\n  }\n}\n\nexport default App;\n","const reportWebVitals = onPerfEntry => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}